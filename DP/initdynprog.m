% Georg Schildbach, 26/May/2015 --- DP for Parking
% Initializes DP parking problem, generates and compiles C-code
% --------------------------------------------------------------------------------------------------
% OUTPUTS
% dplaw: data structure for DP controller
% dynprog.c: solves dynamic program for particular obstacle configuration
% pathplan.c: solves path planning problem for particular initial condition
% pathtrack.c: tracks the planned path by a feedback loop
% --------------------------------------------------------------------------------------------------

clc
clear all
close all

% 1) Inputs ----------------------------------------------------------------------------------------

% 1.1) Working Directory

dir = '/Users/schilgeo/Google Drive/Documents/Berkeley/Research/Paper 08 - DPPark/matlab';

% 1.2) Map for DP

origin = [0, 0, 0];          % global coordinates of the origin of the local map
xyrange = [-15, 15, 0, 10];  % boundary of local map [xmin, xmax, ymin, ymax]
xygrid = [ -3.5,  3.5, 0, 4; ...
          -15, 15, 3, 10];   % range of the grids [xmin, xmax, ymin, ymax] (row vectors)
xres = [61; 61];             % grid resolutions in x-direction (column vector)
yres = [41; 11];             % grid resolutions in y-direction (column vector)
pres = [24; 24];             % grid resolutions in phi-direction (column vector)
Targ = [-1.3, 1.5, 0; ...
         1.3, 1.5, pi];      % list of target positions in local map [x,y,phi] (row vectors)

% 1.3) DP Parameters

maxarc = 6;                  % maximum number of arcs per path
phitol = 0.1;                % tolerance for matching angles in grid points [rad]
condis = 0.5;                % discretization for checking constraints on paths [m]

% 1.4) Car Model (for Dynamic Programming)

auto.w = 2.0;                % car width [m]
auto.l = 5.0;                % car length [m]
auto.db = 1.2;               % rear axis position, from back [m]
auto.df = 1.0;               % front axis position, from front [m]
auto.tyr = 0.8;              % tyre diameter [m]
auto.dmax = 25*pi/180;       % maximum front wheel steering angle [rad]
auto.drat = 14.5;            % ratio between steering wheel angle and front wheel angle
auto.d = auto.l - auto.df - auto.db;  % axis distance [m]

% 1.5) Real Car (for Simulation)

car.w = 2.0;                 % car width [m]
car.l = 5.0;                 % car length [m]
car.db = 1.2;                % rear axis position, from back [m]
car.df = 1.0;                % front axis position, from front [m]
car.vidle = 1.0;             % maximum velocity with idle acc [m/s]
car.tyr = 0.8;               % tyre diameter [m]
car.amax = 1.5;              % maximum acceleration [m/s^2]
car.bmax = 3.0;              % maximum brake [m/s^2]
car.dmax = 37*pi/180;        % maximum front wheel steering angle [rad]
car.rmax = 10*pi/180;        % maximum front wheel steering rate [rad/s]
car.drat = 14.5;             % ratio between steering wheel angle and front wheel angle
car.d = car.l - car.df - car.db;     % axis distance [m]

% 2) Computation  ----------------------------------------------------------------------------------

% 2.1) Map-based Computations

M = [cos(origin(3)),sin(origin(3));-sin(origin(3)),cos(origin(3))];
if size(xygrid,1) ~= size(xres,1)
    error('Grid description has inconsistent dimension!')
end
if size(xygrid,1) ~= size(yres,1)
    error('Grid description has inconsistent dimension!')
end
if size(xygrid,1) ~= size(pres,1)
    error('Grid description has inconsistent dimension!')
end
nres = size(xres,1);

% 2.2) Conversion of Target Positions

sTar = size(Targ,1);
if size(Targ,2) ~= 3
    error('Vector of target positions has inconsistent dimension!')
end
Tar = zeros(1,sTar*3);
for k = 1:sTar
    Tar(1,(k-1)*3+1:(k-1)*3+3) = Targ(k,1:3);
end

% 2.3) Path Separator

str = findstr('/',dir);
if isempty(str)
    str = findstr('\',dir);
    if isempty(str)
        error('Could not identify operating system.')
    else
        psep = '\';
    end
else
    psep = '/';
end
clear str

% 2.4) Initialize Path

sPath = 0;
Path = zeros(1,8*maxarc);

% 3) Store Data  -----------------------------------------------------------------------------------

save('dplaw','Path','sPath','dir','origin','M','xyrange','xygrid','xres','yres','pres','nres','Targ','Tar','sTar','maxarc','phitol','condis','auto','car')

% Code Generation ==================================================================================

% 4) Dynamic Programming ---------------------------------------------------------------------------

l = 1;
L{l} = ['#include "mex.h"']; l=l+1;
L{l} = ['#include "math.h"']; l=l+1;
L{l} = ['#include "time.h"']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['/* Gateway Function --------------------------------------------------------------------------------']; l=l+1;
L{l} = [' * Georg Schildbach, 05/May/2015 --- Dynamic Programming Parking']; l=l+1;
L{l} = [' * Gateway function for Matlab']; l=l+1;
L{l} = [' * -------------------------------------------------------------------------------------------------']; l=l+1;
L{l} = [' * [C,Xgrid,Ygrid,Pgrid] = dynprog(sObs,Obs)']; l=l+1;
L{l} = [' * -------------------------------------------------------------------------------------------------']; l=l+1;
L{l} = [' * INPUTS']; l=l+1;
L{l} = [' * sObs: number of vertex points per obstacle, vector size nObs = no. of obstacles']; l=l+1;
L{l} = [' * Obs: vertex points for each obstacle, vector size 2*sum(sObs)']; l=l+1;
L{l} = [' * -------------------------------------------------------------------------------------------------']; l=l+1;
L{l} = [' * OUTPUTS']; l=l+1;
L{l} = [' * C: computed control law - x, y, phi, number of arcs, total distance, forward / backward, target']; l=l+1;
L{l} = [' *    point']; l=l+1;
L{l} = [' * Xgrid,Ygrid,Pgrid: discrete grid in x, y, phi directions']; l=l+1;
L{l} = [' * maxarc: maximum number of arcs']; l=l+1;
L{l} = [' * -------------------------------------------------------------------------------------------------']; l=l+1;
L{l} = ['*/']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['void mexFunction(int nlhs, mxArray *plhs[],']; l=l+1;
L{l} = ['                 int nrhs, const mxArray *prhs[])  // output, input (number, pointers)']; l=l+1;
L{l} = ['{']; l=l+1;
L{l} = ['    // 1) Inputs -----------------------------------------------------------------------------------']; l=l+1;
L{l} = ['    ']; l=l+1;
L{l} = ['    int i, j, k, l, m, n, o, kc, oc;']; l=l+1;
L{l} = ['    int ipos, jpos;']; l=l+1;
L{l} = ['    int coll, obscoll;']; l=l+1;
L{l} = ['    int nObs;']; l=l+1;
L{l} = ['    int vObs = 4;']; l=l+1;
L{l} = ['    double kd, kcd;']; l=l+1;
L{l} = ['    double axd, Rmin;']; l=l+1;
L{l} = ['    double S, R, d, alpha, arclength;']; l=l+1;
L{l} = ['    double aux1, aux2;']; l=l+1;
L{l} = ['    double x, y, phi;']; l=l+1;
L{l} = ['    double xy[2], v[2], M[2];']; l=l+1;
L{l} = ['    clock_t start, end;']; l=l+1;
L{l} = ['    double cpu_time_used;']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 1.1) Parameters']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    int xres[' num2str(nres,'%i') '];                // x-grid resolution']; l=l+1;
L{l} = ['    int yres[' num2str(nres,'%i') '];                // y-grid resolution']; l=l+1;
L{l} = ['    int pres[' num2str(nres,'%i') '];                // phi-grid resolution']; l=l+1;
L{l} = ['    int maxarc = ' num2str(maxarc-1,'%i') ';              // maximum number of arcs']; l=l+1;
L{l} = ['    int con = 16;                // number of points for constraint checking']; l=l+1;
L{l} = ['    double Const[32];            // x,y points for constraint checking    ']; l=l+1;
L{l} = ['    double phitol = ' num2str(phitol,'%.4f') ';      // tolerance for matching grid points in angle']; l=l+1;
L{l} = ['    double condis = ' num2str(condis,'%.3f') ';       // resolution for checking of constraint violations']; l=l+1;
L{l} = ['    int sTar = ' num2str(sTar,'%i') ';                // number of target positions']; l=l+1;
L{l} = ['    double Tar[' num2str(3*sTar,'%i') '];               // list of target positions']; l=l+1;
L{l} = ['    double Gobs[200];            // H-representation matrix of obstacles']; l=l+1;
L{l} = ['    double hobs[100];            // H-representation vector of obstacles']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 1.2) Function Inputs and Outputs']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    double *sObs;                // number of points for each obstacle']; l=l+1;
L{l} = ['    double *Obs;                 // list of obstacle positions']; l=l+1;
L{l} = ['    double *C;                   // control law']; l=l+1;
L{l} = ['    double *Xgrid;               // x-grid']; l=l+1;
L{l} = ['    double *Ygrid;               // y-grid']; l=l+1;
L{l} = ['    double *Pgrid;               // phi-grid']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 2) Inputs ----------------------------------------------------------------------------------- ']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 2.1) Function Inputs']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    sObs = mxGetPr(prhs[0]);  // vector of size nObs']; l=l+1;
L{l} = ['    nObs = mxGetN(prhs[0]);']; l=l+1;
L{l} = ['    Obs = mxGetPr(prhs[1]);  // vector of size 2*sum(sObs)']; l=l+1;
L{l} = ['    o = mxGetN(prhs[1]);']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 2.2) Hardcoded Inputs']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    axd = ' num2str(auto.l,'%.2f') ' - ' num2str(auto.df,'%.2f') ' - ' num2str(auto.db,'%.2f') ';               // axis distance [m]']; l=l+1;
L{l} = ['    Rmin = axd/tan(' num2str(auto.dmax,'%.2f') ');                   // minimum turning radius [m]']; l=l+1;
L{l} = ['    Const[ 0] = -' num2str(auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    Const[ 1] =  ' num2str(auto.w/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[ 2] = -' num2str(auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    Const[ 3] = -' num2str(auto.w/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[ 4] =  0;']; l=l+1;
L{l} = ['    Const[ 5] =  ' num2str(auto.w/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[ 6] =  0;']; l=l+1;
L{l} = ['    Const[ 7] = -' num2str(auto.w/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[ 8] =  ' num2str((auto.l-auto.df-auto.db)/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[ 9] =  ' num2str(auto.w/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[10] =  ' num2str((auto.l-auto.df-auto.db)/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[11] = -' num2str(auto.w/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[12] =  ' num2str(auto.l-auto.db-auto.df,'%.2f') ';']; l=l+1;
L{l} = ['    Const[13] =  ' num2str(auto.w/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[14] =  ' num2str(auto.l-auto.db-auto.df,'%.2f') ';']; l=l+1;
L{l} = ['    Const[15] = -' num2str(auto.w/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[16] =  ' num2str(auto.l-auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    Const[17] =  ' num2str(auto.w/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[18] =  ' num2str(auto.l-auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    Const[19] = -' num2str(auto.w/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[20] = -' num2str(auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    Const[21] =  ' num2str(auto.w/4,'%.2f') ';']; l=l+1;
L{l} = ['    Const[22] = -' num2str(auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    Const[23] = -' num2str(auto.w/4,'%.2f') ';    ']; l=l+1;
L{l} = ['    Const[24] = -' num2str(auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    Const[25] =  0;']; l=l+1;
L{l} = ['    Const[26] =  ' num2str(auto.l-auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    Const[27] =  ' num2str(auto.w/4,'%.2f') ';']; l=l+1;
L{l} = ['    Const[28] =  ' num2str(auto.l-auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    Const[29] = -' num2str(auto.w/4,'%.2f') ';']; l=l+1;
L{l} = ['    Const[30] =  ' num2str(auto.l-auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    Const[31] =  0;']; l=l+1;
for k = 1:sTar
L{l} = ['    Tar[' num2str((k-1)*3+0,'%i') '] = ' num2str(Tar((k-1)*3+1),'%.2f') ';']; l=l+1;
L{l} = ['    Tar[' num2str((k-1)*3+1,'%i') '] = ' num2str(Tar((k-1)*3+2),'%.2f') ';']; l=l+1;
L{l} = ['    Tar[' num2str((k-1)*3+2,'%i') '] = ' num2str(Tar((k-1)*3+3),'%.8f') ';']; l=l+1;
end
for k = 1:nres
L{l} = ['    xres[' num2str(k-1,'%i') '] = ' num2str(xres(k,1),'%i') ';               // x-grid resolution']; l=l+1;
L{l} = ['    yres[' num2str(k-1,'%i') '] = ' num2str(yres(k,1),'%i') ';               // y-grid resolution']; l=l+1;
L{l} = ['    pres[' num2str(k-1,'%i') '] = ' num2str(pres(k,1),'%i') ';               // phi-grid resolution']; l=l+1;
end
L{l} = ['']; l=l+1;
L{l} = ['    // 3) Outputs ---------------------------------------------------------------------------------- ']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    plhs[0] = mxCreateDoubleMatrix(1,' num2str(7*(sTar+sum(xres.*yres.*pres)),'%i') ',mxREAL);  // vector of size 7*(sTar+xres*yres*pres)']; l=l+1;
L{l} = ['    C = mxGetPr(plhs[0]);']; l=l+1;
L{l} = ['    plhs[1] = mxCreateDoubleMatrix(1,' num2str(sum(xres),'%i') ',mxREAL);  // vector of size sum(xres)']; l=l+1;
L{l} = ['    Xgrid = mxGetPr(plhs[1]);']; l=l+1;
L{l} = ['    plhs[2] = mxCreateDoubleMatrix(1,' num2str(sum(yres),'%i') ',mxREAL);  // vector of size sum(yres)']; l=l+1;
L{l} = ['    Ygrid = mxGetPr(plhs[2]);']; l=l+1;
L{l} = ['    plhs[3] = mxCreateDoubleMatrix(1,' num2str(sum(pres),'%i') ',mxREAL);  // vector of size sum(pres)']; l=l+1;
L{l} = ['    Pgrid = mxGetPr(plhs[3]);']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 4) Input Checking ---------------------------------------------------------------------------']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    if (nrhs!=2) {']; l=l+1;
L{l} = ['        printf("Input Error (dynprog): dynprog requires 2 inputs!");']; l=l+1;
L{l} = ['        return;']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    for (n=0;n<nObs;n++) {']; l=l+1;
L{l} = ['        vObs = vObs + sObs[n];']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    if (vObs>100) {']; l=l+1;
L{l} = ['        printf("InputError (dynprog): Too many obstacle points (change of c-code required)!");']; l=l+1;
L{l} = ['        return;']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    if (o!=2*(vObs-4)) {']; l=l+1;
L{l} = ['        printf("InputError (dynprog): Number of obstacle points is inconsistent with obstacle point list!");']; l=l+1;
L{l} = ['        return;']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 5) Pre-Computations -------------------------------------------------------------------------']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 5.1) Pre-Computations']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    start = clock();']; l=l+1;
L{l} = ['    if (phitol>3.141592653589793/' num2str(min(pres),'%i') ') {']; l=l+1;
L{l} = ['        phitol = 3.141592653589793/' num2str(min(pres),'%i') ';    // phi tolerance [rad]']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 5.2) H-Representation of Obstacles']; l=l+1;
L{l} = ['    ']; l=l+1;
L{l} = ['    oc = 0;']; l=l+1;
L{l} = ['    for (o=0;o<nObs;o++) {']; l=l+1;
L{l} = ['        l = sObs[o];']; l=l+1;
L{l} = ['        for (n=0;n<l-1;n++) {']; l=l+1;
L{l} = ['            Gobs[2*oc  ] = Obs[2*oc+1] - Obs[2*(oc+1)+1];']; l=l+1;
L{l} = ['            Gobs[2*oc+1] = Obs[2*(oc+1)  ] - Obs[2*oc  ];']; l=l+1;
L{l} = ['            hobs[oc] = Gobs[2*oc  ]*Obs[2*oc  ] + Gobs[2*oc+1]*Obs[2*oc+1];']; l=l+1;
L{l} = ['            oc++;']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['        Gobs[2*oc  ] = Obs[2*oc+1] - Obs[2*(oc+1-l)+1];']; l=l+1;
L{l} = ['        Gobs[2*oc+1] = Obs[2*(oc+1-l)  ] - Obs[2*oc  ];']; l=l+1;
L{l} = ['        hobs[oc] = Gobs[2*oc  ]*Obs[2*oc  ] + Gobs[2*oc+1]*Obs[2*oc+1];']; l=l+1;
L{l} = ['        oc++;']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    ']; l=l+1;
L{l} = ['    // 5.3) Set Up Grid']; l=l+1;
L{l} = ['    ']; l=l+1;
L{l} = ['    d = ' num2str(auto.w,'%.2f') '/2;']; l=l+1;
L{l} = ['    if (d>' num2str(auto.db,'%.2f') ') {']; l=l+1;
L{l} = ['        d = ' num2str(auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    if (d>' num2str(auto.l,'%.2f') '+' num2str(auto.df,'%.2f') ') {']; l=l+1;
L{l} = ['        d = ' num2str(auto.l,'%.2f') '+' num2str(auto.df,'%.2f') ';']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    S = (' num2str(xygrid(1,2),'%.2f') '-(' num2str(xygrid(1,1),'%.2f') ')-2*d)/(xres[0]-1);']; l=l+1;
L{l} = ['    for (i=0;i<xres[0];i++) {']; l=l+1;
L{l} = ['        Xgrid[i] = ' num2str(xygrid(1,1),'%.2f') '+d+i*S;']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    S = (' num2str(xygrid(1,4),'%.2f') '-(' num2str(xygrid(1,3),'%.2f') ')-2*d)/(yres[0]-1);']; l=l+1;
L{l} = ['    for (i=0;i<yres[0];i++) {']; l=l+1;
L{l} = ['        Ygrid[i] = ' num2str(xygrid(1,3),'%.2f') '+d+i*S;']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    S = 6.283185307179586/pres[0];']; l=l+1;
L{l} = ['    for (i=0;i<pres[0];i++) {']; l=l+1;
L{l} = ['        Pgrid[i] = i*S;']; l=l+1;
L{l} = ['    } ']; l=l+1;
for k = 2:nres
    L{l} = ['    S = (' num2str(xygrid(k,2),'%.2f') '-(' num2str(xygrid(k,1),'%.2f') ')-2*d)/(xres[' num2str(k-1,'%i') ']-1);']; l=l+1;
    L{l} = ['    for (i=0;i<' num2str(xres(k,1),'%i') ';i++) {']; l=l+1;
    L{l} = ['        Xgrid[' num2str(sum(xres(1:k-1,1)),'%i') '+i] = ' num2str(xygrid(k,1),'%.2f') '+d+i*S;']; l=l+1;
    L{l} = ['    }']; l=l+1;
    L{l} = ['    S = (' num2str(xygrid(k,4),'%.2f') '-(' num2str(xygrid(k,3),'%.2f') ')-2*d)/(yres[' num2str(k-1,'%i') ']-1);']; l=l+1;
    L{l} = ['    for (i=0;i<' num2str(yres(k,1),'%i') ';i++) {']; l=l+1;
    L{l} = ['        Ygrid[' num2str(sum(yres(1:k-1,1)),'%i') '+i] = ' num2str(xygrid(k,3),'%.2f') '+d+i*S;']; l=l+1;
    L{l} = ['    }']; l=l+1;
    L{l} = ['    S = 6.283185307179586/pres[0];']; l=l+1;
    L{l} = ['    for (i=0;i<' num2str(pres(k,1),'%i') ';i++) {']; l=l+1;
    L{l} = ['        Pgrid[' num2str(sum(pres(1:k-1,1)),'%i') '+i] = i*S;']; l=l+1;
    L{l} = ['    } ']; l=l+1; 
end
L{l} = ['']; l=l+1;
L{l} = ['    // 5.4) Set Up Control Law      ']; l=l+1;
L{l} = ['    ']; l=l+1;
L{l} = ['    for (l=0;l<sTar;l++) {']; l=l+1;
L{l} = ['        C[l*7  ] = Tar[l*3  ];  // x']; l=l+1;
L{l} = ['        C[l*7+1] = Tar[l*3+1];  // y']; l=l+1;
L{l} = ['        C[l*7+2] = Tar[l*3+2];  // phi']; l=l+1;
L{l} = ['        C[l*7+3] = 0;            // number of arcs']; l=l+1;
L{l} = ['        C[l*7+4] = 0;            // total distance']; l=l+1;
L{l} = ['        C[l*7+5] = 0;            // forward = +1, backward = -1']; l=l+1;
L{l} = ['        C[l*7+6] = i;            // target point']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    for (n=0;n<' num2str(nres,'%i') ';n++){']; l=l+1;
L{l} = ['        oc = sTar*7;']; l=l+1;
L{l} = ['        for (m=0;m<n;m++){']; l=l+1;
L{l} = ['           oc = oc + xres[m]*yres[m]*pres[m]*7;']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['        for (i=0;i<xres[n];i++) {']; l=l+1;
L{l} = ['            for (j=0;j<yres[n];j++) {']; l=l+1;
L{l} = ['                for (k=0;k<pres[n];k++) {']; l=l+1;
L{l} = ['                    o = oc + (i*yres[n]*pres[n]+j*pres[n]+k)*7;']; l=l+1;
L{l} = ['                    l = 0;']; l=l+1;
L{l} = ['                    for (m=0;m<n;m++) {']; l=l+1;
L{l} = ['                    	 l = l + xres[m];']; l=l+1;
L{l} = ['                    }']; l=l+1;
L{l} = ['                    C[o  ] = Xgrid[l+i]; // x']; l=l+1;
L{l} = ['                    l = 0;']; l=l+1;
L{l} = ['                    for (m=0;m<n;m++) {']; l=l+1;
L{l} = ['                    	 l = l + yres[m];']; l=l+1;
L{l} = ['                    }']; l=l+1;
L{l} = ['                    C[o+1] = Ygrid[l+j]; // y']; l=l+1;
L{l} = ['                    l = 0;']; l=l+1;
L{l} = ['                    for (m=0;m<n;m++) {']; l=l+1;
L{l} = ['                    	 l = l + pres[m];']; l=l+1;
L{l} = ['                    }']; l=l+1;
L{l} = ['                    C[o+2] = Pgrid[l+k]; // phi']; l=l+1;
L{l} = ['                    C[o+3] = 2*maxarc;   // number of arcs']; l=l+1;
L{l} = ['                    C[o+4] = 1e14;       // total distance']; l=l+1;
L{l} = ['                    C[o+5] = 0;          // forward = +1, backward = -1']; l=l+1;
L{l} = ['                    C[o+6] = 0;          // target point']; l=l+1;
L{l} = ['               }']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 6) Build Control Policy ---------------------------------------------------------------------']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    for (m=0;m<maxarc;m++) {']; l=l+1;
L{l} = ['    ']; l=l+1;
L{l} = ['    for (i=0;i<' num2str(sTar+sum(xres.*yres.*pres),'%i') ';i++) { // shoot out: base point (fix)']; l=l+1;
L{l} = ['    ipos = i*7;']; l=l+1;
L{l} = ['    v[0] = cos(C[ipos+2]);']; l=l+1;
L{l} = ['    v[1] = sin(C[ipos+2]);']; l=l+1;
L{l} = ['    if (C[ipos+3]==m) {']; l=l+1;
L{l} = ['        ']; l=l+1;
L{l} = ['        for (j=' num2str(sTar,'%i') ';j<' num2str(sTar+sum(xres.*yres.*pres),'%i') ';j++) { // shoot out: target point (approx)']; l=l+1;
L{l} = ['        jpos = j*7;']; l=l+1;
L{l} = ['        if ( (C[jpos+3]>m) ) {']; l=l+1;
L{l} = ['            aux1 = (C[jpos  ]-C[ipos  ])*v[0] + (C[jpos+1]-C[ipos+1])*v[1];']; l=l+1;
L{l} = ['            aux2 = (C[jpos  ]-C[ipos  ])*v[1] - (C[jpos+1]-C[ipos+1])*v[0];']; l=l+1;
L{l} = ['            ']; l=l+1;
L{l} = ['            // 6.1) Straight Steering']; l=l+1;
L{l} = ['            ']; l=l+1;
L{l} = ['            if ((aux2<1e-8) && (aux2>-1e-8)) { ']; l=l+1;
L{l} = ['                S = C[ipos+2] - C[jpos+2];']; l=l+1;
L{l} = ['                if (S<-phitol) { S = S + 6.283185307179586; }']; l=l+1;
L{l} = ['                if (S>6.283185307179586) { S = S - 6.283185307179586; }']; l=l+1;
L{l} = ['                if ((S<phitol) && (S>-phitol)) {']; l=l+1;
L{l} = ['                    arclength = sqrt((C[jpos]-C[ipos])*(C[jpos]-C[ipos]) + (C[jpos+1]-C[ipos+1])*(C[jpos+1]-C[ipos+1]));']; l=l+1;
L{l} = ['                    if (C[ipos+4]+arclength<C[jpos+4]) {']; l=l+1;
L{l} = ['                        coll = 0;']; l=l+1;
L{l} = ['                        kc = arclength/condis;']; l=l+1;
L{l} = ['                        for (k=0;k<kc;k++) { if (coll<1) { // check constraints']; l=l+1;
L{l} = ['                            kd = k+1;']; l=l+1;
L{l} = ['                            kcd = kc;']; l=l+1;
L{l} = ['                            phi = kd/kcd;']; l=l+1;
L{l} = ['                            x =   C[ipos  ] + phi*(C[jpos  ]-C[ipos  ]);']; l=l+1;
L{l} = ['                            y =   C[ipos+1] + phi*(C[jpos+1]-C[ipos+1]);']; l=l+1;
L{l} = ['                            phi = C[ipos+2] + phi*(C[jpos+2]-C[ipos+2]);']; l=l+1;
L{l} = ['                            for (l=0;l<con;l++) { if (coll<1) {']; l=l+1;
L{l} = ['                                xy[0] = x + cos(phi)*Const[2*l  ] - sin(phi)*Const[2*l+1];']; l=l+1;
L{l} = ['                                xy[1] = y + sin(phi)*Const[2*l  ] + cos(phi)*Const[2*l+1];']; l=l+1;
L{l} = ['                                if ((xy[0] < ' num2str(xyrange(1,1),'%.2f') ') || (xy[0] > ' num2str(xyrange(1,2),'%.2f') ')) {']; l=l+1;
L{l} = ['                                    coll = 2;']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                                if ((xy[1] < ' num2str(xyrange(1,3),'%.2f') ') || (xy[1] > ' num2str(xyrange(1,4),'%.2f') ')) {']; l=l+1;
L{l} = ['                                    coll = 2;']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                                oc = 0;']; l=l+1;
L{l} = ['                                for (o=0;o<nObs;o++) {']; l=l+1;
L{l} = ['                                    obscoll = 2;']; l=l+1;
L{l} = ['                                    for (n=0;n<sObs[o];n++) {']; l=l+1;
L{l} = ['                                        S = Gobs[2*oc  ]*xy[0] + Gobs[2*oc+1]*xy[1] - hobs[oc];']; l=l+1;
L{l} = ['                                        oc++;']; l=l+1;
L{l} = ['                                        if (S>=0) {']; l=l+1;
L{l} = ['                                            obscoll = 0;']; l=l+1;
L{l} = ['                                        }']; l=l+1;
L{l} = ['                                    }']; l=l+1;
L{l} = ['                                    if (obscoll>1) {']; l=l+1;
L{l} = ['                                        coll = 2;']; l=l+1;
L{l} = ['                                    }']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                            }}']; l=l+1;
L{l} = ['                        }}']; l=l+1;
L{l} = ['                        if (coll<1) {']; l=l+1;
L{l} = ['                            C[jpos+3] = m+1;                  // update arcs']; l=l+1;
L{l} = ['                            C[jpos+4] = C[ipos+4]+arclength;  // update distance']; l=l+1;
L{l} = ['                            if (aux1>0) {']; l=l+1;
L{l} = ['                                C[jpos+5] = -1;               // update direction']; l=l+1;
L{l} = ['                            }']; l=l+1;
L{l} = ['                            else {']; l=l+1;
L{l} = ['                                C[jpos+5] = +1;               // update direction']; l=l+1;
L{l} = ['                            }']; l=l+1;
L{l} = ['                            C[jpos+6] = i+1;                  // update target point']; l=l+1;
L{l} = ['                        }']; l=l+1;
L{l} = ['                    }']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['            // 6.2) Right Steering']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['            else if (aux2>=1e-8) {']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['                // Forward shoot out (backward driving)']; l=l+1;
L{l} = ['                S = (C[jpos]-C[ipos])*(C[jpos]-C[ipos])+(C[jpos+1]-C[ipos+1])*(C[jpos+1]-C[ipos+1]);']; l=l+1;
L{l} = ['                R =  S/2/aux2;']; l=l+1;
L{l} = ['                if (R>=Rmin) {']; l=l+1;
L{l} = ['                if (aux1>0) { // front']; l=l+1;
L{l} = ['                    alpha = asin(sqrt(S)/2/R);']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                else {        // back']; l=l+1;
L{l} = ['                    alpha = 3.141592653589793 - asin(sqrt(S)/2/R);']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                S = C[ipos+2] - C[jpos+2] - 2*alpha;']; l=l+1;
L{l} = ['                if (S<-phitol) { S = S + 6.283185307179586; }']; l=l+1;
L{l} = ['                if (S>6.283185307179586) { S = S - 6.283185307179586; }']; l=l+1;
L{l} = ['                if ((S<phitol) && (S>-phitol)) {']; l=l+1;
L{l} = ['                    arclength = 2*alpha*R;']; l=l+1;
L{l} = ['                    if (C[ipos+4]+arclength<C[jpos+4]) {']; l=l+1;
L{l} = ['                        M[0] = C[ipos  ] + R*v[1];']; l=l+1;
L{l} = ['                        M[1] = C[ipos+1] - R*v[0];']; l=l+1;
L{l} = ['                        coll = 0;']; l=l+1;
L{l} = ['                        kc = arclength/condis;']; l=l+1;
L{l} = ['                        for (k=0;k<kc;k++) { if (coll<1) { // check constraints']; l=l+1;
L{l} = ['                            kd = k+1;']; l=l+1;
L{l} = ['                            kcd = kc;']; l=l+1;
L{l} = ['                            phi = kd/kcd;']; l=l+1;
L{l} = ['                            phi = C[ipos+2] - 2*phi*alpha;']; l=l+1;
L{l} = ['                            x =   M[0] - R*sin(phi);']; l=l+1;
L{l} = ['                            y =   M[1] + R*cos(phi);']; l=l+1;
L{l} = ['                            for (l=0;l<con;l++) { if (coll<1) {']; l=l+1;
L{l} = ['                                xy[0] = x + cos(phi)*Const[2*l  ] - sin(phi)*Const[2*l+1];']; l=l+1;
L{l} = ['                                xy[1] = y + sin(phi)*Const[2*l  ] + cos(phi)*Const[2*l+1];']; l=l+1;
L{l} = ['                                if ((xy[0] < ' num2str(xyrange(1,1),'%.2f') ') || (xy[0] > ' num2str(xyrange(1,2),'%.2f') ')) {']; l=l+1;
L{l} = ['                                    coll = 2;']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                                if ((xy[1] < ' num2str(xyrange(1,3),'%.2f') ') || (xy[1] > ' num2str(xyrange(1,4),'%.2f') ')) {']; l=l+1;
L{l} = ['                                    coll = 2;']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                                oc = 0;']; l=l+1;
L{l} = ['                                for (o=0;o<nObs;o++) {']; l=l+1;
L{l} = ['                                    obscoll = 2;']; l=l+1;
L{l} = ['                                    for (n=0;n<sObs[o];n++) {']; l=l+1;
L{l} = ['                                        S = Gobs[2*oc  ]*xy[0] + Gobs[2*oc+1]*xy[1] - hobs[oc];']; l=l+1;
L{l} = ['                                        oc++;']; l=l+1;
L{l} = ['                                        if (S>=0) {']; l=l+1;
L{l} = ['                                            obscoll = 0;']; l=l+1;
L{l} = ['                                        }']; l=l+1;
L{l} = ['                                    }']; l=l+1;
L{l} = ['                                    if (obscoll>1) {']; l=l+1;
L{l} = ['                                        coll = 2;']; l=l+1;
L{l} = ['                                    }']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                            }}']; l=l+1;
L{l} = ['                        }}']; l=l+1;
L{l} = ['                        if (coll<1) {']; l=l+1;
L{l} = ['                            C[jpos+3] = m+1;                  // update arcs']; l=l+1;
L{l} = ['                            C[jpos+4] = C[ipos+4]+arclength;  // update distance']; l=l+1;
L{l} = ['                            C[jpos+5] = -1;                   // update direction']; l=l+1;
L{l} = ['                            C[jpos+6] = i+1;                  // update target point']; l=l+1;
L{l} = ['                        }']; l=l+1;
L{l} = ['                    }']; l=l+1;
L{l} = ['                }}']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['                // Backward shoot out (forward driving)']; l=l+1;
L{l} = ['                S = (C[jpos]-C[ipos])*(C[jpos]-C[ipos])+(C[jpos+1]-C[ipos+1])*(C[jpos+1]-C[ipos+1]);']; l=l+1;
L{l} = ['                R =  S/2/aux2;']; l=l+1;
L{l} = ['                if (R>=Rmin) {']; l=l+1;
L{l} = ['                if (aux1<=0) { // back']; l=l+1;
L{l} = ['                    alpha = asin(sqrt(S)/2/R);']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                else {         // front']; l=l+1;
L{l} = ['                    alpha = 3.141592653589793 - asin(sqrt(S)/2/R);']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                S = C[ipos+2] - C[jpos+2] + 2*alpha;']; l=l+1;
L{l} = ['                if (S<-phitol) { S = S + 6.283185307179586; }']; l=l+1;
L{l} = ['                if (S>6.283185307179586) { S = S - 6.283185307179586; }']; l=l+1;
L{l} = ['                if ((S<phitol) && (S>-phitol)) {']; l=l+1;
L{l} = ['                    arclength = 2*alpha*R;']; l=l+1;
L{l} = ['                    if (C[ipos+4]+arclength<C[jpos+4]) {']; l=l+1;
L{l} = ['                        M[0] = C[ipos  ] + R*v[1];']; l=l+1;
L{l} = ['                        M[1] = C[ipos+1] - R*v[0];']; l=l+1;
L{l} = ['                        coll = 0;']; l=l+1;
L{l} = ['                        kc = arclength/condis;']; l=l+1;
L{l} = ['                        for (k=0;k<kc;k++) { if (coll<1) { // check constraints']; l=l+1;
L{l} = ['                            kd = k+1;']; l=l+1;
L{l} = ['                            kcd = kc;']; l=l+1;
L{l} = ['                            phi = kd/kcd;']; l=l+1;
L{l} = ['                            phi = C[ipos+2] + 2*phi*alpha;']; l=l+1;
L{l} = ['                            x =   M[0] - R*sin(phi);']; l=l+1;
L{l} = ['                            y =   M[1] + R*cos(phi);']; l=l+1;
L{l} = ['                            for (l=0;l<con;l++) { if (coll<1) {']; l=l+1;
L{l} = ['                                xy[0] = x + cos(phi)*Const[2*l  ] - sin(phi)*Const[2*l+1];']; l=l+1;
L{l} = ['                                xy[1] = y + sin(phi)*Const[2*l  ] + cos(phi)*Const[2*l+1];']; l=l+1;
L{l} = ['                                if ((xy[0] < ' num2str(xyrange(1,1),'%.2f') ') || (xy[0] > ' num2str(xyrange(1,2),'%.2f') ')) {']; l=l+1;
L{l} = ['                                    coll = 2;']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                                if ((xy[1] < ' num2str(xyrange(1,3),'%.2f') ') || (xy[1] > ' num2str(xyrange(1,4),'%.2f') ')) {']; l=l+1;
L{l} = ['                                    coll = 2;']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                                oc = 0;']; l=l+1;
L{l} = ['                                for (o=0;o<nObs;o++) {']; l=l+1;
L{l} = ['                                    obscoll = 2;']; l=l+1;
L{l} = ['                                    for (n=0;n<sObs[o];n++) {']; l=l+1;
L{l} = ['                                        S = Gobs[2*oc  ]*xy[0] + Gobs[2*oc+1]*xy[1] - hobs[oc];']; l=l+1;
L{l} = ['                                        oc++;']; l=l+1;
L{l} = ['                                        if (S>=0) {']; l=l+1;
L{l} = ['                                            obscoll = 0;']; l=l+1;
L{l} = ['                                        }']; l=l+1;
L{l} = ['                                    }']; l=l+1;
L{l} = ['                                    if (obscoll>1) {']; l=l+1;
L{l} = ['                                        coll = 2;']; l=l+1;
L{l} = ['                                    }']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                            }}']; l=l+1;
L{l} = ['                        }}']; l=l+1;
L{l} = ['                        if (coll<1) {']; l=l+1;
L{l} = ['                            C[jpos+3] = m+1;                  // update arcs']; l=l+1;
L{l} = ['                            C[jpos+4] = C[ipos+4]+arclength;  // update distance']; l=l+1;
L{l} = ['                            C[jpos+5] = +1;                   // update direction']; l=l+1;
L{l} = ['                            C[jpos+6] = i+1;                  // update target point']; l=l+1;
L{l} = ['                        }']; l=l+1;
L{l} = ['                    }']; l=l+1;
L{l} = ['                }}']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['            // 6.3) Left Steering']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['            else if (aux2<=1e-8) {']; l=l+1;
L{l} = ['                ']; l=l+1;
L{l} = ['                // Forward shoot out (backward driving)']; l=l+1;
L{l} = ['                S = (C[jpos]-C[ipos])*(C[jpos]-C[ipos])+(C[jpos+1]-C[ipos+1])*(C[jpos+1]-C[ipos+1]);']; l=l+1;
L{l} = ['                R = -S/2/aux2;']; l=l+1;
L{l} = ['                if (R>=Rmin) {']; l=l+1;
L{l} = ['                if (aux1>0) { // front']; l=l+1;
L{l} = ['                    alpha = asin(sqrt(S)/2/R);']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                else {        // back']; l=l+1;
L{l} = ['                    alpha = 3.141592653589793 - asin(sqrt(S)/2/R);']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                S = C[ipos+2] - C[jpos+2] + 2*alpha;']; l=l+1;
L{l} = ['                if (S<-phitol) { S = S + 6.283185307179586; }']; l=l+1;
L{l} = ['                if (S>6.283185307179586) { S = S - 6.283185307179586; }']; l=l+1;
L{l} = ['                if ((S<phitol) && (S>-phitol)) {']; l=l+1;
L{l} = ['                    arclength = 2*alpha*R;']; l=l+1;
L{l} = ['                    if (C[ipos+4]+arclength<C[jpos+4]) {']; l=l+1;
L{l} = ['                        M[0] = C[ipos  ] - R*v[1];']; l=l+1;
L{l} = ['                        M[1] = C[ipos+1] + R*v[0];']; l=l+1;
L{l} = ['                        coll = 0;']; l=l+1;
L{l} = ['                        kc = arclength/condis;']; l=l+1;
L{l} = ['                        for (k=0;k<kc;k++) { if (coll<1) { // check constraints']; l=l+1;
L{l} = ['                            kd = k+1;']; l=l+1;
L{l} = ['                            kcd = kc;']; l=l+1;
L{l} = ['                            phi = kd/kcd;']; l=l+1;
L{l} = ['                            phi = C[ipos+2] + 2*phi*alpha;']; l=l+1;
L{l} = ['                            x =   M[0] + R*sin(phi);']; l=l+1;
L{l} = ['                            y =   M[1] - R*cos(phi);']; l=l+1;
L{l} = ['                            for (l=0;l<con;l++) { if (coll<1) {']; l=l+1;
L{l} = ['                                xy[0] = x + cos(phi)*Const[2*l  ] - sin(phi)*Const[2*l+1];']; l=l+1;
L{l} = ['                                xy[1] = y + sin(phi)*Const[2*l  ] + cos(phi)*Const[2*l+1];']; l=l+1;
L{l} = ['                                if ((xy[0] < ' num2str(xyrange(1,1),'%.2f') ') || (xy[0] > ' num2str(xyrange(1,2),'%.2f') ')) {']; l=l+1;
L{l} = ['                                    coll = 2;']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                                if ((xy[1] < ' num2str(xyrange(1,3),'%.2f') ') || (xy[1] > ' num2str(xyrange(1,4),'%.2f') ')) {']; l=l+1;
L{l} = ['                                    coll = 2;']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                                oc = 0;']; l=l+1;
L{l} = ['                                for (o=0;o<nObs;o++) {']; l=l+1;
L{l} = ['                                    obscoll = 2;']; l=l+1;
L{l} = ['                                    for (n=0;n<sObs[o];n++) {']; l=l+1;
L{l} = ['                                        S = Gobs[2*oc  ]*xy[0] + Gobs[2*oc+1]*xy[1] - hobs[oc];']; l=l+1;
L{l} = ['                                        oc++;']; l=l+1;
L{l} = ['                                        if (S>=0) {']; l=l+1;
L{l} = ['                                            obscoll = 0;']; l=l+1;
L{l} = ['                                        }']; l=l+1;
L{l} = ['                                    }']; l=l+1;
L{l} = ['                                    if (obscoll>1) {']; l=l+1;
L{l} = ['                                        coll = 2;']; l=l+1;
L{l} = ['                                    }']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                            }}']; l=l+1;
L{l} = ['                        }}']; l=l+1;
L{l} = ['                        if (coll<1) {']; l=l+1;
L{l} = ['                            C[jpos+3] = m+1;                  // update arcs']; l=l+1;
L{l} = ['                            C[jpos+4] = C[ipos+4]+arclength;  // update distance']; l=l+1;
L{l} = ['                            C[jpos+5] = -1;                   // update direction']; l=l+1;
L{l} = ['                            C[jpos+6] = i+1;                  // update target point']; l=l+1;
L{l} = ['                        }']; l=l+1;
L{l} = ['                    }']; l=l+1;
L{l} = ['                }}']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['                // Backward shoot out (forward driving)']; l=l+1;
L{l} = ['                S = (C[jpos]-C[ipos])*(C[jpos]-C[ipos])+(C[jpos+1]-C[ipos+1])*(C[jpos+1]-C[ipos+1]);']; l=l+1;
L{l} = ['                R = -S/2/aux2;']; l=l+1;
L{l} = ['                if (R>=Rmin) {']; l=l+1;
L{l} = ['                if (aux1<=0) { // back']; l=l+1;
L{l} = ['                    alpha = asin(sqrt(S)/2/R);']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                else {         // front']; l=l+1;
L{l} = ['                    alpha = 3.141592653589793 - asin(sqrt(S)/2/R);']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                S = C[ipos+2] - C[jpos+2] - 2*alpha;']; l=l+1;
L{l} = ['                if (S<-phitol) { S = S + 6.283185307179586; }']; l=l+1;
L{l} = ['                if (S>6.283185307179586) { S = S - 6.283185307179586; }']; l=l+1;
L{l} = ['                if ((S<phitol) && (S>-phitol)) {']; l=l+1;
L{l} = ['                    arclength = 2*alpha*R;']; l=l+1;
L{l} = ['                    if (C[ipos+4]+arclength<C[jpos+4]) {']; l=l+1;
L{l} = ['                        M[0] = C[ipos  ] - R*v[1];']; l=l+1;
L{l} = ['                        M[1] = C[ipos+1] + R*v[0];']; l=l+1;
L{l} = ['                        coll = 0;']; l=l+1;
L{l} = ['                        kc = arclength/condis;']; l=l+1;
L{l} = ['                        for (k=0;k<kc;k++) { if (coll<1) { // check constraints']; l=l+1;
L{l} = ['                            kd = k+1;']; l=l+1;
L{l} = ['                            kcd = kc;']; l=l+1;
L{l} = ['                            phi = kd/kcd;']; l=l+1;
L{l} = ['                            phi = C[ipos+2] - 2*phi*alpha;']; l=l+1;
L{l} = ['                            x =   M[0] + R*sin(phi);']; l=l+1;
L{l} = ['                            y =   M[1] - R*cos(phi);']; l=l+1;
L{l} = ['                            for (l=0;l<con;l++) { if (coll<1) {']; l=l+1;
L{l} = ['                                xy[0] = x + cos(phi)*Const[2*l  ] - sin(phi)*Const[2*l+1];']; l=l+1;
L{l} = ['                                xy[1] = y + sin(phi)*Const[2*l  ] + cos(phi)*Const[2*l+1];']; l=l+1;
L{l} = ['                                if ((xy[0] < ' num2str(xyrange(1,1),'%.2f') ') || (xy[0] > ' num2str(xyrange(1,2),'%.2f') ')) {']; l=l+1;
L{l} = ['                                    coll = 2;']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                                if ((xy[1] < ' num2str(xyrange(1,3),'%.2f') ') || (xy[1] > ' num2str(xyrange(1,4),'%.2f') ')) {']; l=l+1;
L{l} = ['                                    coll = 2;']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                                oc = 0;']; l=l+1;
L{l} = ['                                for (o=0;o<nObs;o++) {']; l=l+1;
L{l} = ['                                    obscoll = 2;']; l=l+1;
L{l} = ['                                    for (n=0;n<sObs[o];n++) {']; l=l+1;
L{l} = ['                                        S = Gobs[2*oc  ]*xy[0] + Gobs[2*oc+1]*xy[1] - hobs[oc];']; l=l+1;
L{l} = ['                                        oc++;']; l=l+1;
L{l} = ['                                        if (S>=0) {']; l=l+1;
L{l} = ['                                            obscoll = 0;']; l=l+1;
L{l} = ['                                        }']; l=l+1;
L{l} = ['                                    }']; l=l+1;
L{l} = ['                                    if (obscoll>1) {']; l=l+1;
L{l} = ['                                        coll = 2;']; l=l+1;
L{l} = ['                                    }']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                            }}']; l=l+1;
L{l} = ['                        }}']; l=l+1;
L{l} = ['                        if (coll<1) {']; l=l+1;
L{l} = ['                            C[jpos+3] = m+1;                  // update arcs']; l=l+1;
L{l} = ['                            C[jpos+4] = C[ipos+4]+arclength;  // update distance']; l=l+1;
L{l} = ['                            C[jpos+5] = +1;                   // update direction']; l=l+1;
L{l} = ['                            C[jpos+6] = i+1;                  // update target point']; l=l+1;
L{l} = ['                        }']; l=l+1;
L{l} = ['                    }']; l=l+1;
L{l} = ['                }}']; l=l+1;
L{l} = ['                ']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['        }}']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    }}}']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 7) Timing -----------------------------------------------------------------------------------']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    end = clock();']; l=l+1;
L{l} = ['    cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;']; l=l+1;
L{l} = ['    i = cpu_time_used/60;']; l=l+1;
L{l} = ['    j = cpu_time_used - 60*i;']; l=l+1;
L{l} = ['    printf("\\n");']; l=l+1;
L{l} = ['    printf("\\n Time to build control law: %%i min %%i sec.\\n", i, j);']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    k = 0;']; l=l+1;
L{l} = ['    for (i=0;i<' num2str(sTar+sum(xres.*yres.*pres),'%i') ';i++) {']; l=l+1;
L{l} = ['        if (C[i*7+3]<=maxarc) {']; l=l+1;
L{l} = ['             k++;']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    kd = k; kd = 100*kd/' num2str(sTar+sum(xres.*yres.*pres),'%i') ';']; l=l+1;
L{l} = ['    printf(" Solution found for %%f percent of all initial conditions.\\n", kd);']; l=l+1;
L{l} = ['    printf("\\n");']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['}']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['']; l=l+1;
l = l-1;

fid = fopen([dir psep 'dynprog.c'],'w');
for k = 1:l
    fprintf(fid,[L{k} '\n']);
end
fclose(fid);
mex 'dynprog.c'

% 5) Path Planner ----------------------------------------------------------------------------------

l = 1;
L{l} = ['#include "mex.h"']; l=l+1;
L{l} = ['#include "math.h"']; l=l+1;
L{l} = ['#include "time.h"']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['/* Gateway Function --------------------------------------------------------------------------------']; l=l+1;
L{l} = [' * Georg Schildbach, 13/May/2015 --- Dynamic Programming Parking']; l=l+1;
L{l} = [' * Gateway function for Matlab']; l=l+1;
L{l} = [' * -------------------------------------------------------------------------------------------------']; l=l+1;
L{l} = [' * [Path,sPath] = pathplan(x0,C,sObs,Obs)']; l=l+1;
L{l} = [' * -------------------------------------------------------------------------------------------------']; l=l+1;
L{l} = [' * INPUTS']; l=l+1;
L{l} = [' * x0: x, y, phi of the vehicle in the relative coordinate system, vector size 3']; l=l+1;
L{l} = [' * C: control law - x, y, phi, number of arcs, total distance, forward / backward, target point']; l=l+1;
L{l} = [' * sObs: number of vertex points per obstacle, vector size nObs = no. of obstacles']; l=l+1;
L{l} = [' * Obs: vertex points for each obstacle, vector size 2*sum(sObs)']; l=l+1;
L{l} = [' * -------------------------------------------------------------------------------------------------']; l=l+1;
L{l} = [' * OUTPUTS']; l=l+1;
L{l} = [' * Path: computed path from initial condition ']; l=l+1;
L{l} = [' *       - straight: x1, y1,   x2,   y2, -1,     0, forward / backward, target point index in C']; l=l+1;
L{l} = [' *       - curve:    Mx, My, phi1, phi2,  R, delta, forward / backward, target point index in C']; l=l+1;
L{l} = [' * sPath: number of reference points used for path (= -1 if no feasible path found)']; l=l+1;
L{l} = [' * -------------------------------------------------------------------------------------------------']; l=l+1;
L{l} = ['*/']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['void mexFunction(int nlhs, mxArray *plhs[],']; l=l+1;
L{l} = ['                 int nrhs, const mxArray *prhs[])  // output, input (number, pointers)']; l=l+1;
L{l} = ['{']; l=l+1;
L{l} = ['    // 1) Inputs -----------------------------------------------------------------------------------']; l=l+1;
L{l} = ['    ']; l=l+1;
L{l} = ['    int i, j, k, l, n, o, kc, oc;']; l=l+1;
L{l} = ['    int sC;']; l=l+1;
L{l} = ['    int ipos;']; l=l+1;
L{l} = ['    int coll, obscoll;']; l=l+1;
L{l} = ['    int nObs;']; l=l+1;
L{l} = ['    int vObs = 4;']; l=l+1;
L{l} = ['    int maxarc = ' num2str(maxarc-1,'%i') ';']; l=l+1;
L{l} = ['    int arc;']; l=l+1;
L{l} = ['    double kd, kcd;']; l=l+1;
L{l} = ['    double axd, Rmin;']; l=l+1;
L{l} = ['    double S, R, d, alpha, arclength;']; l=l+1;
L{l} = ['    double aux1, aux2;']; l=l+1;
L{l} = ['    double x, y, phi;']; l=l+1;
L{l} = ['    double xy[2], v[2], M[2];']; l=l+1;
L{l} = ['    double cost = 1e15;']; l=l+1;
L{l} = ['    clock_t start, end;']; l=l+1;
L{l} = ['    double cpu_time_used;']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 1.1) Parameters']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    int con = 16;                // number of points for constraint checking']; l=l+1;
L{l} = ['    double Const[32];            // x,y points for constraint checking']; l=l+1;
L{l} = ['    double phitol = ' num2str(phitol,'%.4f') ';      // tolerance for matching grid points in angle']; l=l+1;
L{l} = ['    double condis = ' num2str(condis,'%.3f') ';       // resolution for checking of constraint violations']; l=l+1;
L{l} = ['    double Gobs[200];            // H-representation matrix of obstacles']; l=l+1;
L{l} = ['    double hobs[100];            // H-representation vector of obstacles']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 1.2) Function Inputs and Outputs']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    double *x0;                  // position of the relative coordinate system']; l=l+1;
L{l} = ['    double *C;                   // list of target positions']; l=l+1;
L{l} = ['    double *sObs;                // number of points for each obstacle']; l=l+1;
L{l} = ['    double *Obs;                 // list of obstacle vertices']; l=l+1;
L{l} = ['    double *Path;                // computed path']; l=l+1;
L{l} = ['    double *sPath;               // size of computed path']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 2) Inputs ---------------------------------------------------------------------------------- ']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    x0 = mxGetPr(prhs[0]);  // vector of size 3']; l=l+1;
L{l} = ['    i = mxGetN(prhs[0]);']; l=l+1;
L{l} = ['    C = mxGetPr(prhs[1]);  // vector of size sC*7']; l=l+1;
L{l} = ['    sC = mxGetN(prhs[1]);']; l=l+1;
L{l} = ['    sObs = mxGetPr(prhs[2]);  // vector of size nObs']; l=l+1;
L{l} = ['    nObs = mxGetN(prhs[2]);']; l=l+1;
L{l} = ['    Obs = mxGetPr(prhs[3]);  // vector of size 2*sum(sObs)']; l=l+1;
L{l} = ['    o = mxGetN(prhs[3]);']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 3) Outputs ---------------------------------------------------------------------------------- ']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    plhs[0] = mxCreateDoubleMatrix(1,' num2str(8*maxarc,'%i') ',mxREAL);  // vector of size 8*(maxarc+1)']; l=l+1;
L{l} = ['    Path = mxGetPr(plhs[0]);']; l=l+1;
L{l} = ['    plhs[1] = mxCreateDoubleMatrix(1,1,mxREAL);  // scalar (= -1 if no feasible path) ']; l=l+1;
L{l} = ['    sPath = mxGetPr(plhs[1]);']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 4) Input Checking ---------------------------------------------------------------------------']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    if (nrhs!=4) {']; l=l+1;
L{l} = ['        printf("InputError (pathplan): pathplan requires 4 inputs!");']; l=l+1;
L{l} = ['        return;']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    if (i!=3) {']; l=l+1;
L{l} = ['        printf("InputError (pathplan): input x0 has wrong dimensions!");']; l=l+1;
L{l} = ['        return;']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    for (n=0;n<nObs;n++) {']; l=l+1;
L{l} = ['        vObs = vObs + sObs[n];']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    if (vObs>100) {']; l=l+1;
L{l} = ['        printf("InputError (pathplan): Too many obstacle points (change of c-code required)!");']; l=l+1;
L{l} = ['        return;']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    if (o!=2*(vObs-4)) {']; l=l+1;
L{l} = ['        printf("InputError (pathplan): Number of obstacle points is inconsistent with obstacle point list!");']; l=l+1;
L{l} = ['        return;']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 5) Pre-Computations -------------------------------------------------------------------------']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 5.1) Pre-Computations']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    start = clock();']; l=l+1;
L{l} = ['    kd = sC; kd = kd/7; sC = kd;']; l=l+1;
L{l} = ['    arc = 11*maxarc;']; l=l+1;
L{l} = ['    axd = ' num2str(auto.l,'%.2f') ' - ' num2str(auto.db,'%.2f') ' - ' num2str(auto.df,'%.2f') ';          // axis distance [m]']; l=l+1;
L{l} = ['    Rmin = axd/tan(' num2str(auto.dmax,'%.2f') ');              // minimum turning radius [m]']; l=l+1;
L{l} = ['    Const[ 0] = -' num2str(auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    Const[ 1] =  ' num2str(auto.w/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[ 2] = -' num2str(auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    Const[ 3] = -' num2str(auto.w/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[ 4] =  0;']; l=l+1;
L{l} = ['    Const[ 5] =  ' num2str(auto.w/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[ 6] =  0;']; l=l+1;
L{l} = ['    Const[ 7] = -' num2str(auto.w/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[ 8] =  ' num2str((auto.l-auto.df-auto.db)/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[ 9] =  ' num2str(auto.w/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[10] =  ' num2str((auto.l-auto.df-auto.db)/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[11] = -' num2str(auto.w/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[12] =  ' num2str(auto.l-auto.db-auto.df,'%.2f') ';']; l=l+1;
L{l} = ['    Const[13] =  ' num2str(auto.w/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[14] =  ' num2str(auto.l-auto.db-auto.df,'%.2f') ';']; l=l+1;
L{l} = ['    Const[15] = -' num2str(auto.w/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[16] =  ' num2str(auto.l-auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    Const[17] =  ' num2str(auto.w/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[18] =  ' num2str(auto.l-auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    Const[19] = -' num2str(auto.w/2,'%.2f') ';']; l=l+1;
L{l} = ['    Const[20] = -' num2str(auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    Const[21] =  ' num2str(auto.w/4,'%.2f') ';']; l=l+1;
L{l} = ['    Const[22] = -' num2str(auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    Const[23] = -' num2str(auto.w/4,'%.2f') ';    ']; l=l+1;
L{l} = ['    Const[24] = -' num2str(auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    Const[25] =  0;']; l=l+1;
L{l} = ['    Const[26] =  ' num2str(auto.l-auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    Const[27] =  ' num2str(auto.w/4,'%.2f') ';']; l=l+1;
L{l} = ['    Const[28] =  ' num2str(auto.l-auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    Const[29] = -' num2str(auto.w/4,'%.2f') ';']; l=l+1;
L{l} = ['    Const[30] =  ' num2str(auto.l-auto.db,'%.2f') ';']; l=l+1;
L{l} = ['    Const[31] =  0;']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 5.2) H-Representation of Obstacles']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    oc = 0;']; l=l+1;
L{l} = ['    for (o=0;o<nObs;o++) {']; l=l+1;
L{l} = ['        l = sObs[o];']; l=l+1;
L{l} = ['        for (n=0;n<l-1;n++) {']; l=l+1;
L{l} = ['            Gobs[2*oc  ] = Obs[2*oc+1] - Obs[2*(oc+1)+1];']; l=l+1;
L{l} = ['            Gobs[2*oc+1] = Obs[2*(oc+1)  ] - Obs[2*oc  ];']; l=l+1;
L{l} = ['            hobs[oc] = Gobs[2*oc  ]*Obs[2*oc  ] + Gobs[2*oc+1]*Obs[2*oc+1];']; l=l+1;
L{l} = ['            oc++;']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['        Gobs[2*oc  ] = Obs[2*oc+1] - Obs[2*(oc+1-l)+1];']; l=l+1;
L{l} = ['        Gobs[2*oc+1] = Obs[2*(oc+1-l)  ] - Obs[2*oc  ];']; l=l+1;
L{l} = ['        hobs[oc] = Gobs[2*oc  ]*Obs[2*oc  ] + Gobs[2*oc+1]*Obs[2*oc+1];']; l=l+1;
L{l} = ['        oc++;']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 6) Construct Path ---------------------------------------------------------------------------']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    for (i=0;i<sC;i++) { // shoot out: base point (fix)']; l=l+1;
L{l} = ['    ipos = i*7;']; l=l+1;
L{l} = ['    v[0] = cos(C[ipos+2]);']; l=l+1;
L{l} = ['    v[1] = sin(C[ipos+2]);']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['        if ( C[ipos+3]<arc ) { // shoot out: target point = x0']; l=l+1;
L{l} = ['            aux1 = (x0[0]-C[ipos  ])*v[0] + (x0[1]-C[ipos+1])*v[1];']; l=l+1;
L{l} = ['            aux2 = (x0[0]-C[ipos  ])*v[1] - (x0[1]-C[ipos+1])*v[0];']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['            // 6.1) Straight Steering']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['            if ((aux2<1e-8) && (aux2>-1e-8)) { ']; l=l+1;
L{l} = ['                S = C[ipos+2] - x0[2];']; l=l+1;
L{l} = ['                if (S<-phitol) { S = S + 6.283185307179586; }']; l=l+1;
L{l} = ['                if (S>6.283185307179586) { S = S - 6.283185307179586; }']; l=l+1;
L{l} = ['                if ((S<phitol) && (S>-phitol)) {']; l=l+1;
L{l} = ['                    arclength = sqrt((x0[0]-C[ipos])*(x0[0]-C[ipos]) + (x0[1]-C[ipos+1])*(x0[1]-C[ipos+1]));']; l=l+1;
L{l} = ['                    if ( C[ipos+3]+1<arc || C[ipos+4]+arclength<cost ) {']; l=l+1;
L{l} = ['                        coll = 0;']; l=l+1;
L{l} = ['                        kc = arclength/condis;']; l=l+1;
L{l} = ['                        for (k=0;k<kc;k++) { if (coll<1) { // check constraints']; l=l+1;
L{l} = ['                            kd = k+1;']; l=l+1;
L{l} = ['                            kcd = kc;']; l=l+1;
L{l} = ['                            phi = kd/kcd;']; l=l+1;
L{l} = ['                            x =   C[ipos  ] + phi*(x0[0]-C[ipos  ]);']; l=l+1;
L{l} = ['                            y =   C[ipos+1] + phi*(x0[1]-C[ipos+1]);']; l=l+1;
L{l} = ['                            phi = C[ipos+2] + phi*(x0[2]-C[ipos+2]);']; l=l+1;
L{l} = ['                            for (l=0;l<con;l++) { if (coll<1) {']; l=l+1;
L{l} = ['                                xy[0] = x + cos(phi)*Const[2*l  ] - sin(phi)*Const[2*l+1];']; l=l+1;
L{l} = ['                                xy[1] = y + sin(phi)*Const[2*l  ] + cos(phi)*Const[2*l+1];']; l=l+1;
L{l} = ['                                if ((xy[0] < ' num2str(xyrange(1,1),'%.2f') ') || (xy[0] > ' num2str(xyrange(1,2),'%.2f') ')) {']; l=l+1;
L{l} = ['                                    coll = 2;']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                                if ((xy[1] < ' num2str(xyrange(1,3),'%.2f') ') || (xy[1] > ' num2str(xyrange(1,4),'%.2f') ')) {']; l=l+1;
L{l} = ['                                    coll = 2;']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                                oc = 0;']; l=l+1;
L{l} = ['                                for (o=0;o<nObs;o++) {']; l=l+1;
L{l} = ['                                    obscoll = 2;']; l=l+1;
L{l} = ['                                    for (n=0;n<sObs[o];n++) {']; l=l+1;
L{l} = ['                                        S = Gobs[2*oc  ]*xy[0] + Gobs[2*oc+1]*xy[1] - hobs[oc];']; l=l+1;
L{l} = ['                                        oc++;']; l=l+1;
L{l} = ['                                        if (S>=0) {']; l=l+1;
L{l} = ['                                            obscoll = 0;']; l=l+1;
L{l} = ['                                        }']; l=l+1;
L{l} = ['                                    }']; l=l+1;
L{l} = ['                                    if (obscoll>1) {']; l=l+1;
L{l} = ['                                        coll = 2;']; l=l+1;
L{l} = ['                                    }']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                            }}']; l=l+1;
L{l} = ['                        }}']; l=l+1;
L{l} = ['                        if (coll<1) {']; l=l+1;
L{l} = ['                            arc = C[ipos+3]+1;              // update arcs']; l=l+1;
L{l} = ['                            cost = C[ipos+4]+arclength;     // update distance']; l=l+1;
L{l} = ['                            Path[0] = x0[0];                // x1']; l=l+1;
L{l} = ['                            Path[1] = x0[1];                // y1']; l=l+1;
L{l} = ['                            Path[2] = C[ipos  ];            // x2']; l=l+1;
L{l} = ['                            Path[3] = C[ipos+1];            // y2']; l=l+1;
L{l} = ['                            Path[4] = -1;                   // R']; l=l+1;
L{l} = ['                            Path[5] = 0;                    // delta']; l=l+1;
L{l} = ['                            if (aux1>0) {']; l=l+1;
L{l} = ['                                Path[6] = -1;               // update direction']; l=l+1;
L{l} = ['                            }']; l=l+1;
L{l} = ['                            else {']; l=l+1;
L{l} = ['                                Path[6] = +1;               // update direction']; l=l+1;
L{l} = ['                            }']; l=l+1;
L{l} = ['                            Path[7] = i+1;                  // update target point']; l=l+1;
L{l} = ['                        }']; l=l+1;
L{l} = ['                    }']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['            // 6.2) Right Steering']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['            else if (aux2>=1e-8) {']; l=l+1;
L{l} = ['                ']; l=l+1;
L{l} = ['                // Forward shoot out (backward driving)']; l=l+1;
L{l} = ['                S = (x0[0]-C[ipos])*(x0[0]-C[ipos])+(x0[1]-C[ipos+1])*(x0[1]-C[ipos+1]);']; l=l+1;
L{l} = ['                R =  S/2/aux2;']; l=l+1;
L{l} = ['                if (R>=Rmin) {']; l=l+1;
L{l} = ['                if (aux1>0) { // front']; l=l+1;
L{l} = ['                    alpha = asin(sqrt(S)/2/R);']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                else {        // back']; l=l+1;
L{l} = ['                    alpha = 3.141592653589793 - asin(sqrt(S)/2/R);']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                S = C[ipos+2] - x0[2] - 2*alpha;']; l=l+1;
L{l} = ['                if (S<-phitol) { S = S + 6.283185307179586; }']; l=l+1;
L{l} = ['                if (S>6.283185307179586) { S = S - 6.283185307179586; }']; l=l+1;
L{l} = ['                if ((S<phitol) && (S>-phitol)) {']; l=l+1;
L{l} = ['                    arclength = 2*alpha*R;']; l=l+1;
L{l} = ['                    if ( C[ipos+3]+1<arc || C[ipos+4]+arclength<cost ) {']; l=l+1;
L{l} = ['                        M[0] = C[ipos  ] + R*v[1];']; l=l+1;
L{l} = ['                        M[1] = C[ipos+1] - R*v[0];']; l=l+1;
L{l} = ['                        coll = 0;']; l=l+1;
L{l} = ['                        kc = arclength/condis;']; l=l+1;
L{l} = ['                        for (k=0;k<kc;k++) { if (coll<1) { // check constraints']; l=l+1;
L{l} = ['                            kd = k+1;']; l=l+1;
L{l} = ['                            kcd = kc;']; l=l+1;
L{l} = ['                            phi = kd/kcd;']; l=l+1;
L{l} = ['                            phi = C[ipos+2] - 2*phi*alpha;']; l=l+1;
L{l} = ['                            x =   M[0] - R*sin(phi);']; l=l+1;
L{l} = ['                            y =   M[1] + R*cos(phi);']; l=l+1;
L{l} = ['                            for (l=0;l<con;l++) { if (coll<1) {']; l=l+1;
L{l} = ['                                xy[0] = x + cos(phi)*Const[2*l  ] - sin(phi)*Const[2*l+1];']; l=l+1;
L{l} = ['                                xy[1] = y + sin(phi)*Const[2*l  ] + cos(phi)*Const[2*l+1];']; l=l+1;
L{l} = ['                                if ((xy[0] < ' num2str(xyrange(1,1),'%.2f') ') || (xy[0] > ' num2str(xyrange(1,2),'%.2f') ')) {']; l=l+1;
L{l} = ['                                    coll = 2;']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                                if ((xy[1] < ' num2str(xyrange(1,3),'%.2f') ') || (xy[1] > ' num2str(xyrange(1,4),'%.2f') ')) {']; l=l+1;
L{l} = ['                                    coll = 2;']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                                oc = 0;']; l=l+1;
L{l} = ['                                for (o=0;o<nObs;o++) {']; l=l+1;
L{l} = ['                                    obscoll = 2;']; l=l+1;
L{l} = ['                                    for (n=0;n<sObs[o];n++) {']; l=l+1;
L{l} = ['                                        S = Gobs[2*oc  ]*xy[0] + Gobs[2*oc+1]*xy[1] - hobs[oc];']; l=l+1;
L{l} = ['                                        oc++;']; l=l+1;
L{l} = ['                                        if (S>=0) {']; l=l+1;
L{l} = ['                                            obscoll = 0;']; l=l+1;
L{l} = ['                                        }']; l=l+1;
L{l} = ['                                    }']; l=l+1;
L{l} = ['                                    if (obscoll>1) {']; l=l+1;
L{l} = ['                                        coll = 2;']; l=l+1;
L{l} = ['                                    }']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                            }}']; l=l+1;
L{l} = ['                        }}']; l=l+1;
L{l} = ['                        if (coll<1) {']; l=l+1;
L{l} = ['                            arc = C[ipos+3]+1;                 // update arcs']; l=l+1;
L{l} = ['                            cost = C[ipos+4]+arclength;        // update distance']; l=l+1;
L{l} = ['                            Path[0] = M[0];                    // Mx']; l=l+1;
L{l} = ['                            Path[1] = M[1];                    // My']; l=l+1;
L{l} = ['                            Path[2] = C[ipos+2]-2*alpha+1.570796326794897; // phi1']; l=l+1;
L{l} = ['                            if (Path[2]>6.283185307179586) { Path[2] = Path[2]-6.283185307179586; }']; l=l+1;
L{l} = ['                            if (Path[2]<                0) { Path[2] = Path[2]+6.283185307179586; }']; l=l+1;
L{l} = ['                            Path[3] = Path[2]+2*alpha;         // phi2']; l=l+1;
L{l} = ['                            Path[4] = R;                       // R']; l=l+1;
L{l} = ['                            Path[5] = -atan(axd/R);            // delta']; l=l+1;
L{l} = ['                            Path[6] = -1;                      // update direction']; l=l+1;
L{l} = ['                            Path[7] = i+1;                     // update target point']; l=l+1;
L{l} = ['                        }']; l=l+1;
L{l} = ['                    }']; l=l+1;
L{l} = ['                }}']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['                // Backward shoot out (forward driving)']; l=l+1;
L{l} = ['                S = (x0[0]-C[ipos])*(x0[0]-C[ipos])+(x0[1]-C[ipos+1])*(x0[1]-C[ipos+1]);']; l=l+1;
L{l} = ['                R =  S/2/aux2;']; l=l+1;
L{l} = ['                if (R>=Rmin) {']; l=l+1;
L{l} = ['                if (aux1<=0) { // back']; l=l+1;
L{l} = ['                    alpha = asin(sqrt(S)/2/R);']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                else {         // front']; l=l+1;
L{l} = ['                    alpha = 3.141592653589793 - asin(sqrt(S)/2/R);']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                S = C[ipos+2] - x0[2] + 2*alpha;']; l=l+1;
L{l} = ['                if (S<-phitol) { S = S + 6.283185307179586; }']; l=l+1;
L{l} = ['                if (S>6.283185307179586) { S = S - 6.283185307179586; }']; l=l+1;
L{l} = ['                if ((S<phitol) && (S>-phitol)) {']; l=l+1;
L{l} = ['                    arclength = 2*alpha*R;']; l=l+1;
L{l} = ['                    if ( C[ipos+3]+1<arc || C[ipos+4]+arclength<cost ) {']; l=l+1;
L{l} = ['                        M[0] = C[ipos  ] + R*v[1];']; l=l+1;
L{l} = ['                        M[1] = C[ipos+1] - R*v[0];']; l=l+1;
L{l} = ['                        coll = 0;']; l=l+1;
L{l} = ['                        kc = arclength/condis;']; l=l+1;
L{l} = ['                        for (k=0;k<kc;k++) { if (coll<1) { // check constraints']; l=l+1;
L{l} = ['                            kd = k+1;']; l=l+1;
L{l} = ['                            kcd = kc;']; l=l+1;
L{l} = ['                            phi = kd/kcd;']; l=l+1;
L{l} = ['                            phi = C[ipos+2] + 2*phi*alpha;']; l=l+1;
L{l} = ['                            x =   M[0] - R*sin(phi);']; l=l+1;
L{l} = ['                            y =   M[1] + R*cos(phi);']; l=l+1;
L{l} = ['                            for (l=0;l<con;l++) { if (coll<1) {']; l=l+1;
L{l} = ['                                xy[0] = x + cos(phi)*Const[2*l  ] - sin(phi)*Const[2*l+1];']; l=l+1;
L{l} = ['                                xy[1] = y + sin(phi)*Const[2*l  ] + cos(phi)*Const[2*l+1];']; l=l+1;
L{l} = ['                                if ((xy[0] < ' num2str(xyrange(1,1),'%.2f') ') || (xy[0] > ' num2str(xyrange(1,2),'%.2f') ')) {']; l=l+1;
L{l} = ['                                    coll = 2;']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                                if ((xy[1] < ' num2str(xyrange(1,3),'%.2f') ') || (xy[1] > ' num2str(xyrange(1,4),'%.2f') ')) {']; l=l+1;
L{l} = ['                                    coll = 2;']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                                oc = 0;']; l=l+1;
L{l} = ['                                for (o=0;o<nObs;o++) {']; l=l+1;
L{l} = ['                                    obscoll = 2;']; l=l+1;
L{l} = ['                                    for (n=0;n<sObs[o];n++) {']; l=l+1;
L{l} = ['                                        S = Gobs[2*oc  ]*xy[0] + Gobs[2*oc+1]*xy[1] - hobs[oc];']; l=l+1;
L{l} = ['                                        oc++;']; l=l+1;
L{l} = ['                                        if (S>=0) {']; l=l+1;
L{l} = ['                                            obscoll = 0;']; l=l+1;
L{l} = ['                                        }']; l=l+1;
L{l} = ['                                    }']; l=l+1;
L{l} = ['                                    if (obscoll>1) {']; l=l+1;
L{l} = ['                                        coll = 2;']; l=l+1;
L{l} = ['                                    }']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                            }}']; l=l+1;
L{l} = ['                        }}']; l=l+1;
L{l} = ['                        if (coll<1) {']; l=l+1;
L{l} = ['                            arc = C[ipos+3]+1;                 // update arcs']; l=l+1;
L{l} = ['                            cost = C[ipos+4]+arclength;        // update distance']; l=l+1;
L{l} = ['                            Path[0] = M[0];                    // Mx']; l=l+1;
L{l} = ['                            Path[1] = M[1];                    // My']; l=l+1;
L{l} = ['                            Path[2] = C[ipos+2]+2*alpha+1.570796326794897; // phi1']; l=l+1;
L{l} = ['                            if (Path[2]>6.283185307179586) { Path[2] = Path[2]-6.283185307179586; }']; l=l+1;
L{l} = ['                            if (Path[2]<                0) { Path[2] = Path[2]+6.283185307179586; }']; l=l+1;
L{l} = ['                            Path[3] = Path[2]-2*alpha;         // phi2']; l=l+1;
L{l} = ['                            Path[4] = R;                       // R']; l=l+1;
L{l} = ['                            Path[5] = -atan(axd/R);            // delta']; l=l+1;
L{l} = ['                            Path[6] = +1;                      // update direction']; l=l+1;
L{l} = ['                            Path[7] = i+1;                     // update target point']; l=l+1;
L{l} = ['                        }']; l=l+1;
L{l} = ['                    }']; l=l+1;
L{l} = ['                }}']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['            // 6.3) Left Steering']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['            else if (aux2<=-1e-8) {']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['                // Forward shoot out (backward driving)']; l=l+1;
L{l} = ['                S = (x0[0]-C[ipos])*(x0[0]-C[ipos])+(x0[1]-C[ipos+1])*(x0[1]-C[ipos+1]);']; l=l+1;
L{l} = ['                R = -S/2/aux2;']; l=l+1;
L{l} = ['                if (R>=Rmin) {']; l=l+1;
L{l} = ['                if (aux1>0) { // front']; l=l+1;
L{l} = ['                    alpha = asin(sqrt(S)/2/R);']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                else {        // back']; l=l+1;
L{l} = ['                    alpha = 3.141592653589793 - asin(sqrt(S)/2/R);']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                S = C[ipos+2] - x0[2] + 2*alpha;']; l=l+1;
L{l} = ['                if (S<-phitol) { S = S + 6.283185307179586; }']; l=l+1;
L{l} = ['                if (S>6.283185307179586) { S = S - 6.283185307179586; }']; l=l+1;
L{l} = ['                if ((S<phitol) && (S>-phitol)) {']; l=l+1;
L{l} = ['                    arclength = 2*alpha*R;']; l=l+1;
L{l} = ['                    if ( C[ipos+3]+1<arc || C[ipos+4]+arclength<cost ) {']; l=l+1;
L{l} = ['                        M[0] = C[ipos  ] - R*v[1];']; l=l+1;
L{l} = ['                        M[1] = C[ipos+1] + R*v[0];']; l=l+1;
L{l} = ['                        coll = 0;']; l=l+1;
L{l} = ['                        kc = arclength/condis;']; l=l+1;
L{l} = ['                        for (k=0;k<kc;k++) { if (coll<1) { // check constraints']; l=l+1;
L{l} = ['                            kd = k+1;']; l=l+1;
L{l} = ['                            kcd = kc;']; l=l+1;
L{l} = ['                            phi = kd/kcd;']; l=l+1;
L{l} = ['                            phi = C[ipos+2] + 2*phi*alpha;']; l=l+1;
L{l} = ['                            x =   M[0] + R*sin(phi);']; l=l+1;
L{l} = ['                            y =   M[1] - R*cos(phi);']; l=l+1;
L{l} = ['                            for (l=0;l<con;l++) { if (coll<1) {']; l=l+1;
L{l} = ['                                xy[0] = x + cos(phi)*Const[2*l  ] - sin(phi)*Const[2*l+1];']; l=l+1;
L{l} = ['                                xy[1] = y + sin(phi)*Const[2*l  ] + cos(phi)*Const[2*l+1];']; l=l+1;
L{l} = ['                                if ((xy[0] < ' num2str(xyrange(1,1),'%.2f') ') || (xy[0] > ' num2str(xyrange(1,2),'%.2f') ')) {']; l=l+1;
L{l} = ['                                    coll = 2;']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                                if ((xy[1] < ' num2str(xyrange(1,3),'%.2f') ') || (xy[1] > ' num2str(xyrange(1,4),'%.2f') ')) {']; l=l+1;
L{l} = ['                                    coll = 2;']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                                oc = 0;']; l=l+1;
L{l} = ['                                for (o=0;o<nObs;o++) {']; l=l+1;
L{l} = ['                                    obscoll = 2;']; l=l+1;
L{l} = ['                                    for (n=0;n<sObs[o];n++) {']; l=l+1;
L{l} = ['                                        S = Gobs[2*oc  ]*xy[0] + Gobs[2*oc+1]*xy[1] - hobs[oc];']; l=l+1;
L{l} = ['                                        oc++;']; l=l+1;
L{l} = ['                                        if (S>=0) {']; l=l+1;
L{l} = ['                                            obscoll = 0;']; l=l+1;
L{l} = ['                                        }']; l=l+1;
L{l} = ['                                    }']; l=l+1;
L{l} = ['                                    if (obscoll>1) {']; l=l+1;
L{l} = ['                                        coll = 2;']; l=l+1;
L{l} = ['                                    }']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                            }}']; l=l+1;
L{l} = ['                        }}']; l=l+1;
L{l} = ['                        if (coll<1) {']; l=l+1;
L{l} = ['                            arc = C[ipos+3]+1;                 // update arcs']; l=l+1;
L{l} = ['                            cost = C[ipos+4]+arclength;        // update distance']; l=l+1;
L{l} = ['                            Path[0] = M[0];                    // Mx']; l=l+1;
L{l} = ['                            Path[1] = M[1];                    // My']; l=l+1;
L{l} = ['                            Path[2] = C[ipos+2]+2*alpha-1.570796326794897; // phi1']; l=l+1;
L{l} = ['                            if (Path[2]>6.283185307179586) { Path[2] = Path[2]-6.283185307179586; }']; l=l+1;
L{l} = ['                            if (Path[2]<                0) { Path[2] = Path[2]+6.283185307179586; }']; l=l+1;
L{l} = ['                            Path[3] = Path[2]-2*alpha;         // phi2']; l=l+1;
L{l} = ['                            Path[4] = R;                       // R']; l=l+1;
L{l} = ['                            Path[5] = atan(axd/R);             // delta']; l=l+1;
L{l} = ['                            Path[6] = -1;                      // update direction']; l=l+1;
L{l} = ['                            Path[7] = i+1;                     // update target point']; l=l+1;
L{l} = ['                        }']; l=l+1;
L{l} = ['                    }']; l=l+1;
L{l} = ['                }}']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['                // Backward shoot out (forward driving)']; l=l+1;
L{l} = ['                S = (x0[0]-C[ipos])*(x0[0]-C[ipos])+(x0[1]-C[ipos+1])*(x0[1]-C[ipos+1]);']; l=l+1;
L{l} = ['                R = -S/2/aux2;']; l=l+1;
L{l} = ['                if (R>=Rmin) {']; l=l+1;
L{l} = ['                if (aux1<=0) { // back']; l=l+1;
L{l} = ['                    alpha = asin(sqrt(S)/2/R);']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                else {         // front']; l=l+1;
L{l} = ['                    alpha = 3.141592653589793 - asin(sqrt(S)/2/R);']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                S = C[ipos+2] - x0[2] - 2*alpha;']; l=l+1;
L{l} = ['                if (S<-phitol) { S = S + 6.283185307179586; }']; l=l+1;
L{l} = ['                if (S>6.283185307179586) { S = S - 6.283185307179586; }']; l=l+1;
L{l} = ['                if ((S<phitol) && (S>-phitol)) {']; l=l+1;
L{l} = ['                    arclength = 2*alpha*R;']; l=l+1;
L{l} = ['                    if ( C[ipos+3]+1<arc || C[ipos+4]+arclength<cost ) {']; l=l+1;
L{l} = ['                        M[0] = C[ipos  ] - R*v[1];']; l=l+1;
L{l} = ['                        M[1] = C[ipos+1] + R*v[0];']; l=l+1;
L{l} = ['                        coll = 0;']; l=l+1;
L{l} = ['                        kc = arclength/condis;']; l=l+1;
L{l} = ['                        for (k=0;k<kc;k++) { if (coll<1) { // check constraints']; l=l+1;
L{l} = ['                            kd = k+1;']; l=l+1;
L{l} = ['                            kcd = kc;']; l=l+1;
L{l} = ['                            phi = kd/kcd;']; l=l+1;
L{l} = ['                            phi = C[ipos+2] - 2*phi*alpha;']; l=l+1;
L{l} = ['                            x =   M[0] + R*sin(phi);']; l=l+1;
L{l} = ['                            y =   M[1] - R*cos(phi);']; l=l+1;
L{l} = ['                            for (l=0;l<con;l++) { if (coll<1) {']; l=l+1;
L{l} = ['                                xy[0] = x + cos(phi)*Const[2*l  ] - sin(phi)*Const[2*l+1];']; l=l+1;
L{l} = ['                                xy[1] = y + sin(phi)*Const[2*l  ] + cos(phi)*Const[2*l+1];']; l=l+1;
L{l} = ['                                if ((xy[0] < ' num2str(xyrange(1,1),'%.2f') ') || (xy[0] > ' num2str(xyrange(1,2),'%.2f') ')) {']; l=l+1;
L{l} = ['                                    coll = 2;']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                                if ((xy[1] < ' num2str(xyrange(1,3),'%.2f') ') || (xy[1] > ' num2str(xyrange(1,4),'%.2f') ')) {']; l=l+1;
L{l} = ['                                    coll = 2;']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                                oc = 0;']; l=l+1;
L{l} = ['                                for (o=0;o<nObs;o++) {']; l=l+1;
L{l} = ['                                    obscoll = 2;']; l=l+1;
L{l} = ['                                    for (n=0;n<sObs[o];n++) {']; l=l+1;
L{l} = ['                                        S = Gobs[2*oc  ]*xy[0] + Gobs[2*oc+1]*xy[1] - hobs[oc];']; l=l+1;
L{l} = ['                                        oc++;']; l=l+1;
L{l} = ['                                        if (S>=0) {']; l=l+1;
L{l} = ['                                            obscoll = 0;']; l=l+1;
L{l} = ['                                        }']; l=l+1;
L{l} = ['                                    }']; l=l+1;
L{l} = ['                                    if (obscoll>1) {']; l=l+1;
L{l} = ['                                        coll = 2;']; l=l+1;
L{l} = ['                                    }']; l=l+1;
L{l} = ['                                }']; l=l+1;
L{l} = ['                            }}']; l=l+1;
L{l} = ['                        }}']; l=l+1;
L{l} = ['                        if (coll<1) {']; l=l+1;
L{l} = ['                            arc = C[ipos+3]+1;                 // update arcs']; l=l+1;
L{l} = ['                            cost = C[ipos+4]+arclength;        // update distance']; l=l+1;
L{l} = ['                            Path[0] = M[0];                    // Mx']; l=l+1;
L{l} = ['                            Path[1] = M[1];                    // My']; l=l+1;
L{l} = ['                            Path[2] = C[ipos+2]-2*alpha-1.570796326794897; // phi1']; l=l+1;
L{l} = ['                            if (Path[2]>6.283185307179586) { Path[2] = Path[2]-6.283185307179586; }']; l=l+1;
L{l} = ['                            if (Path[2]<                0) { Path[2] = Path[2]+6.283185307179586; }']; l=l+1;
L{l} = ['                            Path[3] = Path[2]+2*alpha;         // phi2']; l=l+1;
L{l} = ['                            Path[4] = R;                       // R']; l=l+1;
L{l} = ['                            Path[5] = atan(axd/R);             // delta']; l=l+1;
L{l} = ['                            Path[6] = +1;                      // update direction']; l=l+1;
L{l} = ['                            Path[7] = i+1;                     // update target point']; l=l+1;
L{l} = ['                        }']; l=l+1;
L{l} = ['                    }']; l=l+1;
L{l} = ['                }}   ']; l=l+1;
L{l} = ['            }   ']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    if ( arc>maxarc+1 ) {']; l=l+1;
L{l} = ['        *sPath = -1;']; l=l+1;
L{l} = ['        return;']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    else {']; l=l+1;
L{l} = ['        *sPath = arc;']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 6.4) Construct Rest of Path']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    for (i=1;i<arc;i++) {']; l=l+1;
L{l} = ['        ipos = 8*i;']; l=l+1;
L{l} = ['        kc = Path[ipos-1]-1;        // current point']; l=l+1;
L{l} = ['        k = C[7*kc+6]-1;            // target point']; l=l+1;
L{l} = ['        Path[ipos+6] = C[7*kc+5];   // direction']; l=l+1;
L{l} = ['        Path[ipos+7] = k+1;         // target point']; l=l+1;
L{l} = ['        aux1 = (C[7*kc]-C[7*k])*cos(C[7*k+2]) + (C[7*kc+1]-C[7*k+1])*sin(C[7*k+2]);']; l=l+1;
L{l} = ['        aux2 = (C[7*kc]-C[7*k])*sin(C[7*k+2]) - (C[7*kc+1]-C[7*k+1])*cos(C[7*k+2]);  ']; l=l+1;
L{l} = ['        if ( aux2<1e-8 && aux2>-1e-8 ) {     // straight']; l=l+1;
L{l} = ['            Path[ipos  ] = C[7*kc  ];  // x1']; l=l+1;
L{l} = ['            Path[ipos+1] = C[7*kc+1];  // y1']; l=l+1;
L{l} = ['            Path[ipos+2] = C[7*k   ];  // x2']; l=l+1;
L{l} = ['            Path[ipos+3] = C[7*k +1];  // y2']; l=l+1;
L{l} = ['            Path[ipos+4] = -1;         // R']; l=l+1;
L{l} = ['            Path[ipos+5] = 0;          // delta']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['        else if ( aux2 > 0 ) {               // right']; l=l+1;
L{l} = ['            S = (C[7*kc]-C[7*k])*(C[7*kc]-C[7*k]) + (C[7*kc+1]-C[7*k+1])*(C[7*kc+1]-C[7*k+1]);']; l=l+1;
L{l} = ['            Path[ipos+4] = +S/2/aux2;                // R']; l=l+1;
L{l} = ['            Path[ipos+5] = -atan(axd/Path[ipos+4]);  // delta']; l=l+1;
L{l} = ['            if      ( C[7*kc+5]<0 && aux1>=0 ) {']; l=l+1;
L{l} = ['                alpha = asin(sqrt(S)/2/Path[ipos+4]);']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['            else if ( C[7*kc+5]>0 && aux1<=0 ) {']; l=l+1;
L{l} = ['                alpha = asin(sqrt(S)/2/Path[ipos+4]);']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['            else {']; l=l+1;
L{l} = ['                alpha = 3.141592653589793 - asin(sqrt(S)/2/Path[ipos+4]);']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['            Path[ipos  ] = C[7*k  ] + Path[ipos+4]*sin(C[7*k+2]);      // Mx']; l=l+1;
L{l} = ['            Path[ipos+1] = C[7*k+1] - Path[ipos+4]*cos(C[7*k+2]);      // My']; l=l+1;
L{l} = ['            if ( C[7*kc+5] < 0 ) {']; l=l+1;
L{l} = ['                Path[ipos+2] = C[7*k+2] - 2*alpha + 1.570796326794897; // phi1']; l=l+1;
L{l} = ['                if (Path[ipos+2]>6.283185307179586) { Path[ipos+2] = Path[ipos+2]-6.283185307179586; }']; l=l+1;
L{l} = ['                if (Path[ipos+2]<                0) { Path[ipos+2] = Path[ipos+2]+6.283185307179586; }']; l=l+1;
L{l} = ['                Path[ipos+3] = Path[ipos+2] + 2*alpha;                 // phi2']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['            else {']; l=l+1;
L{l} = ['                Path[ipos+2] = C[7*k+2] + 2*alpha + 1.570796326794897; // phi1']; l=l+1;
L{l} = ['                if (Path[ipos+2]>6.283185307179586) { Path[ipos+2] = Path[ipos+2]-6.283185307179586; }']; l=l+1;
L{l} = ['                if (Path[ipos+2]<                0) { Path[ipos+2] = Path[ipos+2]+6.283185307179586; }']; l=l+1;
L{l} = ['                Path[ipos+3] = Path[ipos+2] - 2*alpha;                 // phi2']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['        else if ( aux2 < 0 ) {               // left']; l=l+1;
L{l} = ['            S = (C[7*kc]-C[7*k])*(C[7*kc]-C[7*k]) + (C[7*kc+1]-C[7*k+1])*(C[7*kc+1]-C[7*k+1]);']; l=l+1;
L{l} = ['            Path[ipos+4] = -S/2/aux2;                // R']; l=l+1;
L{l} = ['            Path[ipos+5] = +atan(axd/Path[ipos+4]);  // delta']; l=l+1;
L{l} = ['            if      ( C[7*kc+5]<0 && aux1>=0 ) {']; l=l+1;
L{l} = ['                alpha = asin(sqrt(S)/2/Path[ipos+4]);']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['            else if ( C[7*kc+5]>0 && aux1<=0 ) {']; l=l+1;
L{l} = ['                alpha = asin(sqrt(S)/2/Path[ipos+4]);']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['            else {']; l=l+1;
L{l} = ['                alpha = 3.141592653589793 - asin(sqrt(S)/2/Path[ipos+4]);']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['            Path[ipos  ] = C[7*k  ] - Path[ipos+4]*sin(C[7*k+2]);      // M_x']; l=l+1;
L{l} = ['            Path[ipos+1] = C[7*k+1] + Path[ipos+4]*cos(C[7*k+2]);      // M_y       ']; l=l+1;
L{l} = ['            if ( C[7*kc+5] < 0 ) {']; l=l+1;
L{l} = ['                Path[ipos+2] = C[7*k+2] + 2*alpha - 1.570796326794897; // phi1']; l=l+1;
L{l} = ['                if (Path[ipos+2]>6.283185307179586) { Path[ipos+2] = Path[ipos+2]-6.283185307179586; }']; l=l+1;
L{l} = ['                if (Path[ipos+2]<                0) { Path[ipos+2] = Path[ipos+2]+6.283185307179586; }']; l=l+1;
L{l} = ['                Path[ipos+3] = Path[ipos+2] - 2*alpha;                 // phi2']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['            else {']; l=l+1;
L{l} = ['                Path[ipos+2] = C[7*k+2] - 2*alpha - 1.570796326794897; // phi1']; l=l+1;
L{l} = ['                if (Path[ipos+2]>6.283185307179586) { Path[ipos+2] = Path[ipos+2]-6.283185307179586; }']; l=l+1;
L{l} = ['                if (Path[ipos+2]<                0) { Path[ipos+2] = Path[ipos+2]+6.283185307179586; }']; l=l+1;
L{l} = ['                Path[ipos+3] = Path[ipos+2] + 2*alpha;                 // phi2']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 7) Timing -----------------------------------------------------------------------------------']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    end = clock();']; l=l+1;
L{l} = ['    cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;']; l=l+1;
L{l} = ['    printf("\\n Time to compute feasible path: %%f ms.\\n", cpu_time_used);']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    }']; l=l+1;
l = l-1;

fid = fopen([dir psep 'pathplan.c'],'w');
for k = 1:l
    fprintf(fid,[L{k} '\n']);
end
fclose(fid);
mex 'pathplan.c'

% 6) Path Tracker ----------------------------------------------------------------------------------
l = 1;
L{l} = ['#define S_FUNCTION_NAME pathtrack']; l=l+1;
L{l} = ['#define S_FUNCTION_LEVEL 2']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['#include "simstruc.h"']; l=l+1;
L{l} = ['#include "math.h"']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['/* Gateway Function --------------------------------------------------------------------------------']; l=l+1;
L{l} = [' * Georg Schildbach, 05/June/2015 --- Dynamic Programming Parking']; l=l+1;
L{l} = [' * Gateway function for Matlab']; l=l+1;
L{l} = [' * -------------------------------------------------------------------------------------------------']; l=l+1;
L{l} = [' * [c] = pathtrack(x,u,Path,sPath,K)']; l=l+1;
L{l} = [' * -------------------------------------------------------------------------------------------------']; l=l+1;
L{l} = [' * INPUTS']; l=l+1;
L{l} = [' * x: current state (x,y,phi) of the vehicle, vector size 3']; l=l+1;
L{l} = [' * u: current input (abs(v),delta,gear) of the vehicle, vector size 3']; l=l+1;
L{l} = [' * Path: reference path from initial condition x0, vector of size 8*maxarc']; l=l+1;
L{l} = [' * sPath: number of arcs contained in the reference path, scalar']; l=l+1;
L{l} = [' * K: tuning constants of controller, vector of size 10']; l=l+1;
L{l} = [' * -------------------------------------------------------------------------------------------------']; l=l+1;
L{l} = [' * OUTPUTS']; l=l+1;
L{l} = [' * c: new command to car [acceleration, delta, gear]']; l=l+1;
L{l} = [' * b: current controller status [path element, direction, reference steering angle, gear shift']; l=l+1;
L{l} = [' *    mode, steering transition mode, arc transition mode, controller active/inactive, longitudinal']; l=l+1;
L{l} = [' *    way-to-go, lateral error]']; l=l+1;
L{l} = [' * -------------------------------------------------------------------------------------------------']; l=l+1;
L{l} = ['*/']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['static void mdlInitializeSizes(SimStruct *S)  // S: s-function name']; l=l+1;
L{l} = ['{']; l=l+1;
L{l} = ['    ssSetNumSFcnParams(S, 0);                 // s-function, number of expected parameters']; l=l+1;
L{l} = ['    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) {']; l=l+1;
L{l} = ['        return; // Parameter mismatch will be reported by Simulink']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    ssSetNumContStates(S, 0);  // s-function, number of continuous states']; l=l+1;
L{l} = ['    ssSetNumDiscStates(S, 8);  // s-function, number of discrete states']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    if (!ssSetNumInputPorts(S, 6)) return;     // s-function, no of input ports']; l=l+1;
L{l} = ['    ssSetInputPortWidth(S, 0, 3);              // s-function, input port index, size']; l=l+1;
L{l} = ['    ssSetInputPortDirectFeedThrough(S, 0, 1);  // block name, input port index, enable/disable']; l=l+1;
L{l} = ['    ssSetInputPortRequiredContiguous(S, 0, 1); // block name, input port index, enable/disable']; l=l+1;
L{l} = ['    ssSetInputPortWidth(S, 1, 3);              // s-function, input port index, size']; l=l+1;
L{l} = ['    ssSetInputPortDirectFeedThrough(S, 1, 1);  // block name, input port index, enable/disable']; l=l+1;
L{l} = ['    ssSetInputPortRequiredContiguous(S, 1, 1); // block name, input port index, enable/disable']; l=l+1;
L{l} = ['    ssSetInputPortWidth(S, 2, ' num2str(8*maxarc,'%i') ');             // s-function, input port index, size']; l=l+1;
L{l} = ['    ssSetInputPortDirectFeedThrough(S, 2, 1);  // block name, input port index, enable/disable']; l=l+1;
L{l} = ['    ssSetInputPortRequiredContiguous(S, 2, 1); // block name, input port index, enable/disable']; l=l+1;
L{l} = ['    ssSetInputPortWidth(S, 3, 1);              // s-function, input port index, size']; l=l+1;
L{l} = ['    ssSetInputPortDirectFeedThrough(S, 3, 1);  // block name, input port index, enable/disable']; l=l+1;
L{l} = ['    ssSetInputPortRequiredContiguous(S, 3, 1); // block name, input port index, enable/disable']; l=l+1;
L{l} = ['    ssSetInputPortWidth(S, 4, 11);             // s-function, input port index, size']; l=l+1;
L{l} = ['    ssSetInputPortDirectFeedThrough(S, 4, 1);  // block name, input port index, enable/disable']; l=l+1;
L{l} = ['    ssSetInputPortRequiredContiguous(S, 4, 1); // block name, input port index, enable/disable']; l=l+1;
L{l} = ['    ssSetInputPortWidth(S, 5, 3);              // s-function, input port index, size']; l=l+1;
L{l} = ['    ssSetInputPortDirectFeedThrough(S, 5, 1);  // block name, input port index, enable/disable']; l=l+1;
L{l} = ['    ssSetInputPortRequiredContiguous(S, 5, 1); // block name, input port index, enable/disable']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    if (!ssSetNumOutputPorts(S, 2)) return;  // s-function, no of output ports']; l=l+1;
L{l} = ['    ssSetOutputPortWidth(S, 0, 3);           // s-function, output port index, size']; l=l+1;
L{l} = ['    ssSetOutputPortWidth(S, 1, 9);           // s-function, output port index, size']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    ssSetNumSampleTimes(S, 1);']; l=l+1;
L{l} = ['    ssSetNumRWork(S, 0);']; l=l+1;
L{l} = ['    ssSetNumIWork(S, 0);']; l=l+1;
L{l} = ['    ssSetNumPWork(S, 0);']; l=l+1;
L{l} = ['    ssSetNumModes(S, 0);']; l=l+1;
L{l} = ['    ssSetNumNonsampledZCs(S, 0);']; l=l+1;
L{l} = ['    ssSetSimStateCompliance(S, USE_DEFAULT_SIM_STATE);']; l=l+1;
L{l} = ['    ssSetOptions(S, 0);']; l=l+1;
L{l} = ['}']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['static void mdlInitializeSampleTimes(SimStruct *S)     // S: s-function name']; l=l+1;
L{l} = ['{']; l=l+1;
L{l} = ['    ssSetSampleTime(S, 0, 0.01);                       // s-function, sample time index, sample time']; l=l+1;
L{l} = ['    ssSetOffsetTime(S, 0, 0.0);                        // s-function, sample time index, offset time']; l=l+1;
L{l} = ['    ssSetModelReferenceSampleTimeDefaultInheritance(S);    ']; l=l+1;
L{l} = ['}']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['#define MDL_INITIALIZE_CONDITIONS']; l=l+1;
L{l} = ['static void mdlInitializeConditions(SimStruct *S)']; l=l+1;
L{l} = ['{']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 1) Get States -------------------------------------------------------------------------------']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    double       *Z     = ssGetRealDiscStates(S);']; l=l+1;
L{l} = ['    const real_T *u     = ssGetInputPortRealSignal(S,1);']; l=l+1;
L{l} = ['    const real_T *Path  = ssGetInputPortRealSignal(S,2);']; l=l+1;
L{l} = ['    const real_T *K     = ssGetInputPortRealSignal(S,4);']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 2) Initialize -------------------------------------------------------------------------------']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    Z[0] = 0;          // current path element']; l=l+1;
L{l} = ['    Z[1] = 0;          // integral value lateral error']; l=l+1;
L{l} = ['    Z[2] = 0;          // previous lateral error']; l=l+1;
L{l} = ['    if ( (u[2]-Path[7]>1) || (Path[7]-u[2]>1) ) {']; l=l+1;
L{l} = ['        Z[4] = 1;      // gear shift mode on']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    else {']; l=l+1;
L{l} = ['        Z[4] = 0;      // gear shift mode off']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    if      ( u[1]>Path[5]+K[10]*3.141592653589793/180 ) {']; l=l+1;
L{l} = ['        Z[5] = -2;     // steering transition mode on, decrease steering']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    else if ( u[1]<Path[5]-K[10]*3.141592653589793/180 ) {']; l=l+1;
L{l} = ['        Z[5] =  2;     // steering transition mode on, increase steering']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    else {']; l=l+1;
L{l} = ['        Z[5] = 0;      // steering transition mode off']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    Z[6] = 0;          // arc transition mode off']; l=l+1;
L{l} = ['	Z[7] = 0;          // controller active (= 2) or inactive (= 0)']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['}']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['static void mdlOutputs(SimStruct *S, int_T tid)  // S: s-function name, tid: task identifier']; l=l+1;
L{l} = ['{']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 1) Inputs -----------------------------------------------------------------------------------']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    const real_T *X      = ssGetInputPortRealSignal(S,0);']; l=l+1;
L{l} = ['    const real_T *u      = ssGetInputPortRealSignal(S,1);']; l=l+1;
L{l} = ['    const real_T *Path   = ssGetInputPortRealSignal(S,2);']; l=l+1;
L{l} = ['    const real_T *sPath  = ssGetInputPortRealSignal(S,3);']; l=l+1;
L{l} = ['    const real_T *K      = ssGetInputPortRealSignal(S,4);']; l=l+1;
L{l} = ['    const real_T *origin = ssGetInputPortRealSignal(S,5);']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 2) Outputs ----------------------------------------------------------------------------------']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    double     *c       = ssGetOutputPortRealSignal(S,0);']; l=l+1;
L{l} = ['    double     *b       = ssGetOutputPortRealSignal(S,1);']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 3) States -----------------------------------------------------------------------------------']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    double     *Z       = ssGetRealDiscStates(S);']; l=l+1;
L{l} = [' ']; l=l+1;
L{l} = ['    // 4) Main Routine -----------------------------------------------------------------------------']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 4.1) Variable Definitions']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    double dt = 0.01;  // sample time']; l=l+1;
L{l} = ['    int k = Z[0];']; l=l+1;
L{l} = ['    double lat, lon, psi, vref, pref;']; l=l+1;
L{l} = ['    double v1[2];']; l=l+1;
L{l} = ['    double v2[2];']; l=l+1;
L{l} = ['    double x[3];']; l=l+1;
L{l} = ['    Z[1] = 0.8*Z[1];   // anti wind-up']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 4.2) Switch Controller On/Off']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // (De-)Activate']; l=l+1;
L{l} = ['    Z[7] = 2;          // activate controller']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // Active / inactive mode']; l=l+1;
L{l} = ['	if ( Z[7] < 1 ) {      // inactive']; l=l+1;
L{l} = ['		c[0] = -K[7];']; l=l+1;
L{l} = ['		c[1] = 0;']; l=l+1;
L{l} = ['		c[2] = 0;']; l=l+1;
L{l} = ['	}']; l=l+1;
L{l} = ['    else {                 // active']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 4.3) Coordinate Transformation']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    x[0] =  (X[0]-origin[0])*cos(origin[2]) + (X[1]-origin[1])*sin(origin[2]);']; l=l+1;
L{l} = ['    x[1] = -(X[0]-origin[0])*sin(origin[2]) + (X[1]-origin[1])*cos(origin[2]);']; l=l+1;
L{l} = ['    x[2] =  X[2] - origin[2];']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 4.4) Compute lat and lon']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    if      ( Path[8*k+5] == 0 ) {  // straight']; l=l+1;
L{l} = ['        v1[0] = x[0] - Path[8*k  ];']; l=l+1;
L{l} = ['        v1[1] = x[1] - Path[8*k+1];']; l=l+1;
L{l} = ['        v2[0] =  Path[8*k+3] - Path[8*k+1];']; l=l+1;
L{l} = ['        v2[1] = -Path[8*k+2] + Path[8*k  ];']; l=l+1;
L{l} = ['        lat = v2[0]*v2[0] + v2[1]*v2[1];']; l=l+1;
L{l} = ['        lat = Path[8*k+6] * (v1[0]*v2[0] + v1[1]*v2[1]) / sqrt(lat);']; l=l+1;
L{l} = ['        v1[0] = x[0] - Path[8*k+2];']; l=l+1;
L{l} = ['        v1[1] = x[1] - Path[8*k+3];']; l=l+1;
L{l} = ['        v2[0] =  Path[8*k  ] - Path[8*k+2];']; l=l+1;
L{l} = ['        v2[1] =  Path[8*k+1] - Path[8*k+3];']; l=l+1;
L{l} = ['        lon = v2[0]*v2[0] + v2[1]*v2[1];']; l=l+1;
L{l} = ['        lon = (v1[0]*v2[0] + v1[1]*v2[1]) / sqrt(lon);']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    else if ( Path[8*k+5] < 0 ) {   // right']; l=l+1;
L{l} = ['        v1[0] = x[0] - Path[8*k  ];']; l=l+1;
L{l} = ['        v1[1] = x[1] - Path[8*k+1];']; l=l+1;
L{l} = ['        lat = v1[0]*v1[0] + v1[1]*v1[1];']; l=l+1;
L{l} = ['        lat = Path[8*k+4] - sqrt( lat );']; l=l+1;
L{l} = ['        if ( v1[0] == 0 ) {']; l=l+1;
L{l} = ['            if ( v1[1] >= 0 ) { psi = 1.570796326794897; }']; l=l+1;
L{l} = ['            if ( v1[1] <  0 ) { psi = 4.712388980384690; }']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['        else if ( v1[0] > 0 ) {']; l=l+1;
L{l} = ['            if ( v1[1] >= 0 ) { psi = atan(v1[1]/v1[0]); }']; l=l+1;
L{l} = ['            if ( v1[1] <  0 ) { psi = atan(v1[1]/v1[0]) + 6.283185307179586; }']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['        else if ( v1[0] < 0 ) {']; l=l+1;
L{l} = ['            psi = atan(v1[1]/v1[0]) + 3.141592653589793;']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['        if ( Path[8*k+6] < 0.5 ) {  // right and backward (psi increasing)']; l=l+1;
L{l} = ['            if ( Path[8*k+3] > Path[8*k+2] ) {']; l=l+1;
L{l} = ['                if ( psi < Path[8*k+2]-0.2 ) {']; l=l+1;
L{l} = ['                    lon = (Path[8*k+3]-psi-6.283185307179586)*Path[8*k+4];']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                else {']; l=l+1;
L{l} = ['                    lon = (Path[8*k+3]-psi)*Path[8*k+4];']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['            else {']; l=l+1;
L{l} = ['                if ( psi > Path[8*k+2]-0.2 ) {']; l=l+1;
L{l} = ['                    lon = (Path[8*k+3]+6.283185307179586-psi)*Path[8*k+4];']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                else {']; l=l+1;
L{l} = ['                    lon = (Path[8*k+3]-psi)*Path[8*k+4];']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['        if ( Path[8*k+6] > 0.5 ) {  // right and forward (psi decreasing)']; l=l+1;
L{l} = ['            if ( Path[8*k+3] < Path[8*k+2] ) {']; l=l+1;
L{l} = ['                if ( psi > Path[8*k+2]+0.2 ) {']; l=l+1;
L{l} = ['                    lon = (psi-6.283185307179586-Path[8*k+3])*Path[8*k+4];']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                else {']; l=l+1;
L{l} = ['                    lon = (psi-Path[8*k+3])*Path[8*k+4];']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['            else {']; l=l+1;
L{l} = ['                if ( psi < Path[8*k+2]+0.2 ) {']; l=l+1;
L{l} = ['                    lon = (psi-Path[8*k+3]-6.283185307179586)*Path[8*k+4];']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                else {']; l=l+1;
L{l} = ['                    lon = (psi-Path[8*k+3])*Path[8*k+4];']; l=l+1;
L{l} = ['                }     ']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    else if ( Path[8*k+5] > 0 ) {   // left']; l=l+1;
L{l} = ['        v1[0] = x[0] - Path[8*k  ];']; l=l+1;
L{l} = ['        v1[1] = x[1] - Path[8*k+1];']; l=l+1;
L{l} = ['        lat = v1[0]*v1[0] + v1[1]*v1[1];']; l=l+1;
L{l} = ['        lat = sqrt( lat ) - Path[8*k+4];']; l=l+1;
L{l} = ['        if ( v1[0] == 0 ) {']; l=l+1;
L{l} = ['            if ( v1[1] >= 0 ) { psi = 1.570796326794897; }']; l=l+1;
L{l} = ['            if ( v1[1] <  0 ) { psi = 4.712388980384690; }']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['        else if ( v1[0] > 0 ) {']; l=l+1;
L{l} = ['            if ( v1[1] >= 0 ) { psi = atan(v1[1]/v1[0]); }']; l=l+1;
L{l} = ['            if ( v1[1] <  0 ) { psi = atan(v1[1]/v1[0]) + 6.283185307179586; }']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['        else if (v1[0] < 0) {']; l=l+1;
L{l} = ['            psi = atan(v1[1]/v1[0]) + 3.141592653589793;']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['        if ( Path[8*k+6] < 0.5 ) {  // left and backward (psi decreasing)']; l=l+1;
L{l} = ['            if ( Path[8*k+3] < Path[8*k+2] ) {']; l=l+1;
L{l} = ['                if ( psi > Path[8*k+2]+0.2 ) {']; l=l+1;
L{l} = ['                    lon = (psi-6.283185307179586-Path[8*k+3])*Path[8*k+4];']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                else {']; l=l+1;
L{l} = ['                    lon = (psi-Path[8*k+3])*Path[8*k+4];']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['            else {']; l=l+1;
L{l} = ['                if ( psi < Path[8*k+2]+0.2 ) {']; l=l+1;
L{l} = ['                    lon = (psi-Path[8*k+3]-6.283185307179586)*Path[8*k+4];']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                else {']; l=l+1;
L{l} = ['                    lon = (psi-Path[8*k+3])*Path[8*k+4];']; l=l+1;
L{l} = ['                }     ']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['        if ( Path[8*k+6] > 0.5 ) {  // left and forward (psi increasing)']; l=l+1;
L{l} = ['            if ( Path[8*k+3] > Path[8*k+2] ) {']; l=l+1;
L{l} = ['                if ( psi < Path[8*k+2]-0.2 ) {']; l=l+1;
L{l} = ['                    lon = (Path[8*k+3]-psi-6.283185307179586)*Path[8*k+4];']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                else {']; l=l+1;
L{l} = ['                    lon = (Path[8*k+3]-psi)*Path[8*k+4];']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['            else {']; l=l+1;
L{l} = ['                if ( psi > Path[8*k+2]-0.2 ) {']; l=l+1;
L{l} = ['                    lon = (Path[8*k+3]+6.283185307179586-psi)*Path[8*k+4];']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                else {']; l=l+1;
L{l} = ['                    lon = (Path[8*k+3]-psi)*Path[8*k+4];']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 4.5) Compute Input and Determine Arc Transition']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    if ( Z[6] < 1 ) {  // arc transition mode off']; l=l+1;
L{l} = ['        if ( Z[4] < 0.5 ) {  // gear shift mode off']; l=l+1;
L{l} = ['            if ( Z[5]<1 && Z[5]>-1 ) {  // steering transition mode off']; l=l+1;
L{l} = ['                c[0] = 1;     // acceleration']; l=l+1;
L{l} = ['                c[2] = u[2];  // gear']; l=l+1;
L{l} = ['                c[1] = K[0]*lat + K[1]*Z[1] + K[2]*(lat-Z[2])/dt;  // K_p, K_i, K_d']; l=l+1;
L{l} = ['                if ( u[0] < 0.5 ) { c[1] = c[1] / 0.5; }']; l=l+1;
L{l} = ['                else              { c[1] = c[1] / u[0]; }']; l=l+1;
L{l} = ['                c[1] = c[1] + Path[8*k+5];  // steering']; l=l+1;
L{l} = ['                Z[1] = Z[1] + lat*dt;       // integration']; l=l+1;
L{l} = ['                if ( Z[1] >  5 ) { Z[1] =  5; }  // anti wind-up']; l=l+1;
L{l} = ['                if ( Z[1] < -5 ) { Z[1] = -5; }']; l=l+1;
L{l} = ['                Z[2] = lat;                 // derivative']; l=l+1;
L{l} = ['                v1[0] = u[0]/K[7]; // time to stop']; l=l+1;
L{l} = ['                if ( (u[0]*v1[0]-0.5*K[7]*v1[0]*v1[0]) > lon - K[3] ) {']; l=l+1;
L{l} = ['                    Z[6] = 2;']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 4.6) Transition Arc']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    if ( Z[6] > 1 ) { // arc transition mode on']; l=l+1;
L{l} = ['        if ( k > *sPath-2 ) {  // path is finished']; l=l+1;
L{l} = ['            c[0] = -K[7];  // acceleration']; l=l+1;
L{l} = ['            c[1] = 0;      // steering']; l=l+1;
L{l} = ['            c[2] = 0;      // gear']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['        else {  // path is not finished']; l=l+1;
L{l} = ['            if ( Path[8*(k+1)+6]>Path[8*k+6] || Path[8*(k+1)+6]<Path[8*k+6] ) { // gear shift needed']; l=l+1;
L{l} = ['                c[0] = -K[7];  // acceleration']; l=l+1;
L{l} = ['                c[2] = u[2];   // gear']; l=l+1;
L{l} = ['                c[1] = K[0]*lat + K[1]*Z[1] + K[2]*(lat-Z[2])/dt;  // K_p, K_i, K_d']; l=l+1;
L{l} = ['                if ( u[0] < 0.5 ) { c[1] = c[1] / 0.5; }']; l=l+1;
L{l} = ['                else              { c[1] = c[1] / u[0]; }']; l=l+1;
L{l} = ['                c[1] = c[1] + Path[8*k+5];  // steering']; l=l+1;
L{l} = ['                Z[1] = Z[1] + lat*dt;       // integration']; l=l+1;
L{l} = ['                if ( Z[1] >  5 ) { Z[1] =  5; }  // anti wind-up']; l=l+1;
L{l} = ['                if ( Z[1] < -5 ) { Z[1] = -5; }']; l=l+1;
L{l} = ['                Z[2] = lat;                 // derivative']; l=l+1;
L{l} = ['                if ( u[0]<K[9] ) {']; l=l+1;
L{l} = ['                    k++;']; l=l+1;
L{l} = ['                    Z[0] = Z[0]+1;   // next path element']; l=l+1;
L{l} = ['                    Z[6] = 0;        // path transition mode off ']; l=l+1;
L{l} = ['                    Z[4] = 1;        // gear shift mode on']; l=l+1;
L{l} = ['                    if      ( u[1]>Path[k*8+5]+K[10]*3.141592653589793/180 ) {']; l=l+1;
L{l} = ['                        Z[5] = -2;   // steering transition mode on, decrease steering']; l=l+1;
L{l} = ['                    }']; l=l+1;
L{l} = ['                    else if ( u[1]<Path[k*8+5]-K[10]*3.141592653589793/180 ) {']; l=l+1;
L{l} = ['                        Z[5] =  2;   // steering transition mode on, increase steering']; l=l+1;
L{l} = ['                    }']; l=l+1;
L{l} = ['                    else {']; l=l+1;
L{l} = ['                        Z[5] = 0;    // steering transition mode off']; l=l+1;
L{l} = ['                    }']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['            else {  // gear shift not needed']; l=l+1;
L{l} = ['                c[0] = 1;            // acceleration']; l=l+1;
L{l} = ['                c[2] = u[2];         // gear']; l=l+1;
L{l} = ['                c[1] = K[0]*lat + K[1]*Z[1] + K[2]*(lat-Z[2])/dt;  // K_p, K_i, K_d']; l=l+1;
L{l} = ['                if ( u[0] < 0.5 ) { c[1] = c[1] / 0.5; }']; l=l+1;
L{l} = ['                else              { c[1] = c[1] / u[0]; }']; l=l+1;
L{l} = ['                c[1] = c[1] + Path[8*k+5];  // steering']; l=l+1;
L{l} = ['                Z[1] = 0;                   // reset integration']; l=l+1;
L{l} = ['                Z[2] = lat;                 // derivative']; l=l+1;
L{l} = ['                k++;']; l=l+1;
L{l} = ['                Z[0] = Z[0]+1;       // next path element']; l=l+1;
L{l} = ['                Z[6] = 0;            // path transition mode off ']; l=l+1;
L{l} = ['                if      ( u[1]>Path[k*8+5]+K[10]*3.141592653589793/180 ) {']; l=l+1;
L{l} = ['                    Z[5] = -2;   // steering transition mode on, decrease steering']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                else if ( u[1]<Path[k*8+5]-K[10]*3.141592653589793/180 ) {']; l=l+1;
L{l} = ['                    Z[5] =  2;   // steering transition mode on, increase steering']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['                else {']; l=l+1;
L{l} = ['                    Z[5] = 0;    // steering transition mode off']; l=l+1;
L{l} = ['                }']; l=l+1;
L{l} = ['            }']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 4.7) Gear Shift Mode']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    if ( Z[4] > 0.5 ) { // gear shift mode']; l=l+1;
L{l} = ['    	c[0] = -K[7];         // acceleration']; l=l+1;
L{l} = ['        if ( Z[5] < 1 && Z[5] > -1 ) {  // steering transition mode off']; l=l+1;
L{l} = ['            c[1] = u[1];     // steering']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['        c[2] = Path[8*k+6];  // gear']; l=l+1;
L{l} = ['        if ( u[0] < 0.01 ) {']; l=l+1;
L{l} = ['            Z[4] = Z[4]+1;']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    if ( Z[4] > K[4]/dt ) {']; l=l+1;
L{l} = ['        Z[4] = 0; // gear shift complete (after gear shift delay)']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 4.8) Steering Transition Mode']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    if ( Z[5] < -1 ) {  // steering tansition mode on, decrease steering']; l=l+1;
L{l} = ['        c[0] = -K[7];                                    // acceleration']; l=l+1;
L{l} = ['        if ( Z[4] < 0.5 ) { // gear shift mode off']; l=l+1;
L{l} = ['            c[2] = u[2];                                 // gear']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['        if ( u[1] > Path[8*k+5] ) {']; l=l+1;
L{l} = ['            c[1] = u[1] - K[6]*dt*3.141592653589793/180; // steering']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['        else {']; l=l+1;
L{l} = ['            Z[5] = 0;']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    if ( Z[5] > 1 ) {  // steering transition mode on, increase steering']; l=l+1;
L{l} = ['        c[0] = -K[7];                                    // acceleration']; l=l+1;
L{l} = ['        if ( Z[4] < 0.5 ) { // gear shift mode off']; l=l+1;
L{l} = ['            c[2] = u[2];                                 // gear']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['        if ( u[1] < Path[8*k+5] ) {']; l=l+1;
L{l} = ['            c[1] = u[1] + K[6]*dt*3.141592653589793/180; // steering']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['        else {']; l=l+1;
L{l} = ['            Z[5] = 0;']; l=l+1;
L{l} = ['        }']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 4.9) Adjust Inputs for Constraints']; l=l+1;
L{l} = ['    ']; l=l+1;
L{l} = ['    if ( c[0] >  K[7] ) {']; l=l+1;
L{l} = ['        c[0] = K[7];']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    if ( c[0] < -K[7] ) {']; l=l+1;
L{l} = ['        c[0] = -K[7];']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    if ( c[1] > K[5]*3.141592653589793/180 ) { ']; l=l+1;
L{l} = ['        c[1] =  K[5]*3.141592653589793/180; ']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    if ( c[1] < -K[5]*3.141592653589793/180 ) {']; l=l+1;
L{l} = ['        c[1] =  -K[5]*3.141592653589793/180; ']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    if ( c[1] > u[1] + dt*K[6]*3.141592653589793/180 ) { ']; l=l+1;
L{l} = ['        c[1] =  u[1] + dt*K[6]*3.141592653589793/180; ']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['    if ( c[1] < u[1] - dt*K[6]*3.141592653589793/180 ) { ']; l=l+1;
L{l} = ['        c[1] =  u[1] - dt*K[6]*3.141592653589793/180; ']; l=l+1;
L{l} = ['    }']; l=l+1;
L{l} = ['	}']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['    // 5) Output -----------------------------------------------------------------------------------']; l=l+1;
L{l} = ['    ']; l=l+1;
L{l} = ['    b[0] = Z[0];                  // current path element']; l=l+1;
L{l} = ['    b[1] = Path[8*k+6];           // forward / backward']; l=l+1;
L{l} = ['    b[2] = Path[8*k+5];           // reference steering angle']; l=l+1;
L{l} = ['    b[3] = Z[4];                  // gear shift mode']; l=l+1;
L{l} = ['    b[4] = 0;                     // steering transition mode']; l=l+1;
L{l} = ['    if ( Z[5]<-1 ) { b[4] = -1; }']; l=l+1;
L{l} = ['    if ( Z[5]> 1 ) { b[4] =  1; } ']; l=l+1;
L{l} = ['    b[5] = 0;                     // arc transition mode']; l=l+1;
L{l} = ['    if ( Z[6]> 1 ) { b[5] =  1; }        ']; l=l+1;
L{l} = ['    b[6] = 0;                     // controller active/inactive']; l=l+1;
L{l} = ['    if ( Z[7]> 1 ) { b[6] =  1; }']; l=l+1;
L{l} = ['    b[7] = lon;                   // longitudinal way-to-go']; l=l+1;
L{l} = ['    b[8] = lat;                   // lateral error']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['}']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['static void mdlTerminate(SimStruct *S)  // S: s-function name']; l=l+1;
L{l} = ['{']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['}']; l=l+1;
L{l} = ['']; l=l+1;
L{l} = ['#ifdef  MATLAB_MEX_FILE    // Is this file being compiled as a MEX-file?']; l=l+1;
L{l} = ['#include "simulink.c"      // MEX-file interface mechanism']; l=l+1;
L{l} = ['#else']; l=l+1;
L{l} = ['#include "cg_sfun.h"       // Code generation registration function']; l=l+1;
L{l} = ['#endif']; l=l+1;
l = l-1;

fid = fopen([dir psep 'pathtrack.c'],'w');
for k = 1:l
    fprintf(fid,[L{k} '\n']);
end
fclose(fid);
mex 'pathtrack.c'
